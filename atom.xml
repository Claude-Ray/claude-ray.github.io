<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claude&#39;s Blog</title>
  
  <subtitle>Searching</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://claude-ray.com/"/>
  <updated>2022-06-29T04:36:29.781Z</updated>
  <id>http://claude-ray.com/</id>
  
  <author>
    <name>Claude Ray</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 npm 依赖治理</title>
    <link href="http://claude-ray.com/2022/06/28/auditing_npm_packages/"/>
    <id>http://claude-ray.com/2022/06/28/auditing_npm_packages/</id>
    <published>2022-06-28T04:16:30.000Z</published>
    <updated>2022-06-29T04:36:29.781Z</updated>
    
    <content type="html"><![CDATA[<p>想想项目创建之后，多久没给 npm 依赖升级了？</p><p>如何得知当前项目 npm 依赖的”健康度”？</p><p>给老项目升级 npm 依赖，有哪些注意事项？</p><a id="more"></a><h2 id="核心诉求"><a href="#核心诉求" class="headerlink" title="核心诉求"></a>核心诉求</h2><ul><li>提高可维护性。不容易和后引入的依赖产生冲突。引入新特性，功能表现和文档描述接近，后续开发也能得心应手。</li><li>提高可移植性。方便老项目向高版本 npm 或 pnpm 迁移。</li><li>提高可靠性。只要依赖还在稳定迭代，升级必定能引入一系列 bugfix（却也可能引入新 bug）。</li><li>提高安全性。官方社区会及时通告 npm 依赖的安全漏洞，将版本保持在安全范围，能排除许多隐患。</li></ul><h2 id="流程方法"><a href="#流程方法" class="headerlink" title="流程方法"></a>流程方法</h2><ul><li>使用专业的评估工具。手动升级 @latest 等于把依赖当成黑盒来操作。</li><li>按优先级处理。集中精力升级核心依赖，以及含有安全隐患的库，否则时间投入很容易超出预期。</li><li>阅读 changelog，评估升级影响。</li><li>回归测试，十分重要。</li></ul><p>除了回归测试以外，主导治理的人不仅要熟悉项目内容，也要对计划升级的 npm 包有充分了解。如果没有合适的人选，建议继续在代码堆里坚持一会儿，毕竟升级有风险，后果得自负。</p><h2 id="检索工具"><a href="#检索工具" class="headerlink" title="检索工具"></a>检索工具</h2><blockquote><p>以下内容以 npm 为例，pnpm 和 yarn 有可替代的命令。</p></blockquote><h3 id="过时依赖-npm-outdated"><a href="#过时依赖-npm-outdated" class="headerlink" title="过时依赖 npm outdated"></a>过时依赖 npm outdated</h3><p><code>npm outdated</code> 命令会从 npm 源检查已安装的软件包是否已过时。</p><p>随便拿几个包举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Package                             Current   Wanted        Latest  Location</span><br><span class="line">axios                                0.18.1   0.18.1        0.27.2  project-dir</span><br><span class="line">log4js                               2.11.0   2.11.0         6.5.2  project-dir</span><br><span class="line">lru-cache                             4.1.5    4.1.5        7.10.2  project-dir</span><br><span class="line">socket.io                             2.4.1    2.5.0         4.5.1  project-dir</span><br><span class="line">vue                                  2.6.14   2.6.14        3.2.37  project-dir</span><br><span class="line">vue-lazyload                          1.3.3    1.3.4    3.0.0-rc.2  project-dir</span><br><span class="line">vue-loader                           14.2.4   14.2.4        17.0.0  project-dir</span><br><span class="line">vue-router                            3.5.3    3.5.4        4.0.16  project-dir</span><br><span class="line">vuex                                  3.6.2    3.6.2         4.0.2  project-dir</span><br><span class="line">webpack                              3.12.0   3.12.0        5.73.0  project-dir</span><br></pre></td></tr></table></figure><p>默认只会检查项目 package.json 中直接引用的依赖， <code>--all</code> 选项可以用来匹配全部的依赖。但没有必要，真要彻底升级，更推荐尝试重建 lock 文件。</p><p>对于 outdated 的包，使用 <code>npm update</code> 或其他包管理工具对应的 update 命令即可安装 SemVer 标准执行升级。如果想跨越 Major 版本，则需要手动指定升级版本。</p><h3 id="风险依赖-npm-audit"><a href="#风险依赖-npm-audit" class="headerlink" title="风险依赖 npm audit"></a>风险依赖 npm audit</h3><p><code>npm audit</code> 命令同样是向 npm 源发起请求，它将 package-lock.json 作为参数，返回存在已知漏洞的依赖列表。 换句话说，audit 不需要安装 node_modules 就可以执行，其结果完全取决于当前的 package-lock.json。</p><p>返回节选如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run  npm install swiper@8.2.5  to resolve 1 vulnerability</span></span><br><span class="line">SEMVER WARNING: Recommended action is a potentially breaking change</span><br><span class="line">┌───────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class="line">│ Critical      │ Prototype Pollution <span class="keyword">in</span> swiper                                │</span><br><span class="line">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Package       │ swiper                                                       │</span><br><span class="line">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Dependency of │ swiper                                                       │</span><br><span class="line">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Path          │ swiper                                                       │</span><br><span class="line">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class="line">│ More info     │ https://github.com/advisories/GHSA-p3hc-fv2j-rp68            │</span><br><span class="line">└───────────────┴──────────────────────────────────────────────────────────────┘</span><br><span class="line">found 125 vulnerabilities (8 low, 66 moderate, 41 high, 10 critical) <span class="keyword">in</span> 2502 scanned packages</span><br><span class="line">  run `npm audit fix` to fix 15 of them.</span><br><span class="line">  96 vulnerabilities require semver-major dependency updates.</span><br><span class="line">  14 vulnerabilities require manual review. See the full report <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>如果你发现执行结果为 404，说明当前源不支持 audit 接口，可更换到支持 audit 的官方源重新执行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm http fetch POST 404 https://registry.npmmirror.com/-/npm/v1/security/audits 306ms</span><br><span class="line">npm ERR! code ENOAUDIT</span><br><span class="line">npm ERR! audit Your configured registry (https://registry.npmmirror.com/) does not support audit requests.</span><br><span class="line">npm ERR! audit The server said: &lt;h1&gt;404 Not Found&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>结果中虽然提到了 <code>npm audit fix</code> 命令，却不总是可靠的，它能修复的依赖有限，远不如通过升级 root 依赖修复间接依赖带来的数量明显。</p><h3 id="隐式依赖-npx-depcheck"><a href="#隐式依赖-npx-depcheck" class="headerlink" title="隐式依赖 npx depcheck"></a>隐式依赖 npx depcheck</h3><p>npm cli 工具 <code>depcheck</code> 能辅助我们找到项目中 <code>Unused dependencies</code>（无用依赖）和 <code>Phantom dependencies</code>（幻影依赖），分别表示写入 package.json 但没被项目使用、被项目引用了但没有写入 package.json。</p><p>depcheck 更像是一个缩小排查范围的过滤器，不能轻信其打印结果。例如，depcheck 默认无法识别特殊挂载的 plugin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Unused dependencies</span><br><span class="line"> * clipboard</span><br><span class="line"> * cross-env</span><br><span class="line"> * firebase</span><br><span class="line"> * proxy</span><br><span class="line"> * route-cache</span><br><span class="line"> * socket.io</span><br><span class="line">Unused devDependencies</span><br><span class="line"> * add-asset-html-webpack-plugin</span><br><span class="line"> * commitizen</span><br><span class="line"> * eslint</span><br><span class="line"> * husky</span><br><span class="line"> * jasmine</span><br><span class="line"> * rimraf</span><br><span class="line"> * stylelint</span><br><span class="line">Missing dependencies</span><br><span class="line"> * node-notifier: .&#x2F;build&#x2F;utils.js</span><br></pre></td></tr></table></figure><p>要删除一个无用依赖，必须熟悉该 npm 包的使用性质，再结合 grep 工具反复确认。</p><h3 id="僵尸依赖-npm-install"><a href="#僵尸依赖-npm-install" class="headerlink" title="僵尸依赖 npm install"></a>僵尸依赖 npm install</h3><p>最后，还要提防一种 <code>Zombie dependencies</code>（僵尸依赖）。不同于前面介绍的隐式依赖，它的危害很大。</p><p>首先它切实被项目使用，但已经被维护者 deprecated 或 archieved。意味着版本不再更新，包名不会出现在 outdated 列表；很可能没人报告漏洞，也不会出现在 audit 列表。但潜在的 bug 无人修复，它将一直躲藏在项目里，伺机而动。</p><p>笔者没发现合适的工具去寻找僵尸依赖，只好多留意 npm install 的 deprecated 日志。</p><h2 id="治理建议"><a href="#治理建议" class="headerlink" title="治理建议"></a>治理建议</h2><h3 id="如何阅读-CHANGELOG"><a href="#如何阅读-CHANGELOG" class="headerlink" title="如何阅读 CHANGELOG"></a>如何阅读 CHANGELOG</h3><p>changelog 一般位于代码仓库的 <code>CHANGELOG.md</code> 或 <code>History.md</code>，随意一些的也可能放在在 Github 的 <code>releases</code> 页，正式一些的会放在官方网站的 <code>Migrations</code> 类目。</p><p>如果发现一个 npm 包没有 changelog，或 changelog 写得太差，<del>建议换成其他更靠谱的替代品</del> ，就只能靠阅读 commits 了。</p><p>关键词（欢迎补充）：</p><ul><li>BREAKING CHANGE</li><li>!</li><li>Node.js</li></ul><p>开发者普遍会用上面的方式标注不兼容的变更。</p><h3 id="lock-文件版本管理"><a href="#lock-文件版本管理" class="headerlink" title="lock 文件版本管理"></a>lock 文件版本管理</h3><p>该建议是对商业软件的研发流程而言。活跃的开源场景并不需要 lock 文件，为了开发者迭代和测试的过程能趁早发现兼容性问题。</p><p>package-lock.json 的设计文稿就直言推荐把 lock 文件加入代码仓库：</p><ul><li>保证团队成员和 CI 能使用完全相同的依赖关系</li><li>作为 node_modules 的轻量化备份</li><li>让依赖树的变化更具可见性</li><li>加速安装过程</li></ul><p>但是，npm 依赖管理的策略因团队和项目而异，是否提交 lock 文件到 git 仓库可以按需取舍，版本管理的形式还有很多。</p><p>例如研发流程完善，每次发布的 lock 文件都会留在制品库或镜像中，能够随时被还原。可如果缺少相关举措，就要想办法将生产环境的 lock 文件备份，为问题复现、故障恢复提供依据。</p><h3 id="更新-hoisting"><a href="#更新-hoisting" class="headerlink" title="更新 hoisting"></a>更新 hoisting</h3><p>常年累月的更新之下，许多 package-lock.json 的外层依赖的版本会落后于子节点，因为目前 npm 为了保持最小更新幅度，不会对 lock 树做旋转和变形。即使更新的项目的直接依赖到 latest，它的间接依赖可能还是旧的，以致现存的依赖提升结果和默认 hoisting 算法的偏差越来越大。</p><p>一些老项目脱离 package-lock.json 文件之后，甚至无法正常安装构建。此时依赖已经处于非常不健康的状态，开发者需要担心新引入的依赖是否会破坏平衡，无法迁移 npm 包管理工具，也不能升级 Node.js 版本。不过亡羊补牢并不复杂，总好过修复一个没有 package-lock.json 的项目。</p><p>想生成一份可靠的 package-lock.json，最简单的办法就是除旧迎新：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf package-lock.json node_modules</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>更好的办法是换到不使用 hoisting 的依赖管理工具。</p><p>情况讲清楚了，什么时候重建可以看自身需求。但是，将 lock 文件加入 .gitignore 的同学就要注意了，如果别人出现了你本地无法复现的问题，记得先删掉 package-lock.json。</p><h3 id="整理-dependencies-和-devDependencies"><a href="#整理-dependencies-和-devDependencies" class="headerlink" title="整理 dependencies 和 devDependencies"></a>整理 dependencies 和 devDependencies</h3><p>package.json 中 <code>dependencies</code> 和 <code>devDependencies</code> 的区别就不必介绍了，但大家在项目中是否会做严格区分呢？</p><p>一来 devDependencies 是为 npm 包优化依赖关系设计的，作为应用的项目通常不会打包发布到 npm 上；二来不作区分也没有直接带来不良后果。因此经常会有小伙伴将开发环境依赖的工具直接安装到 dependencies 中。</p><p>不过，即使对项目而言，devDependencies 也有积极意义：</p><ul><li>能从语义上划分依赖的用途</li><li>使用 <code>npm install --production</code> 可以忽略 devDependencies，提高安装效率，显著减少 node_modules 的体积</li></ul><p>第二点还需要做个补充说明，由于静态项目的构建环境往往需要安装大部分 devDependencies 中的依赖，一般只有放在服务端运行的 Node.js 项目才需要考虑这么做。但随着 TypeScript 的普及或是 SSR 的引入，这些服务端项目在运行前也需要执行构建。那还有什么用？别忘了，还有一个 <code>npm prune --production</code> 能用作后置的项目体积优化。</p><p>当然了，语义划分带来帮助也足够大了，例如根据依赖关系来优化 npm 治理的优先级和策略。</p><p>顺便再提一句，dependencies 和 devDependencies 不是用来区分重要程度，请不要把运行可有可无的依赖放在 devDependencies，应该放在 <a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#optionaldependencies" target="_blank" rel="noopener">optionaldependencies</a> 中。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上介绍的经验多为概述，主要结合 npm 依赖管理工具的特点，没能介绍 yarn 和 pnpm 等工具独有的 API 和问题，如果读者想了解更多内容，请查阅相关文档。此外，同时使用多种依赖管理工具的项目颇为复杂，比较少见，本文未作分析，也不建议读者朋友们尝试。而在软件工程领域，依赖治理还有很多要点需要我们去进一步实践，不过内容更侧重于 refactor。</p><p>回到标语所提项目依赖的”健康度”，实为笔者胡诌，用来形容依赖关系的混乱程度。不做这些依赖治理，也没有太大关系，因为软件的生命周期往往坚持不到依赖关系崩坏的那天。但混乱的依赖管理，却能轻易促成代码的腐化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想想项目创建之后，多久没给 npm 依赖升级了？&lt;/p&gt;
&lt;p&gt;如何得知当前项目 npm 依赖的”健康度”？&lt;/p&gt;
&lt;p&gt;给老项目升级 npm 依赖，有哪些注意事项？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>记录 Got(Node.js) 代理 HTTP 请求的坑</title>
    <link href="http://claude-ray.com/2021/01/27/node-http-stream-proxy/"/>
    <id>http://claude-ray.com/2021/01/27/node-http-stream-proxy/</id>
    <published>2021-01-27T11:05:25.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>在过去，request 模块几乎是 Node.js 端的不二选择，可惜已被放弃维护。如今流行的模块虽然变多，但不意味着它们足够成熟，我还是倾向于专注 Node.js 端的那几个。</p><p>需求越简单，选择越不重要。不过相较而言，Got 的接口设计看起来更友好，并且它是做到支持 Connection Timeout 和 Read Timeout 的少数。</p><blockquote><p>见 <a href="https://github.com/sindresorhus/got/#comparison" target="_blank" rel="noopener">https://github.com/sindresorhus/got/#comparison</a> 的 Advanced timeouts</p></blockquote><p>实际用下来，还是遇到了坑，顺便扒了一眼 Got 的代码。</p><a id="more"></a><h2 id="native-http"><a href="#native-http" class="headerlink" title="native http?"></a>native http?</h2><p>先解释一下为什么不用原生 http 模块吧。</p><p>毕竟在 Node.js 提供代理服务是非常容易的事儿，普遍的优化无非是：</p><ul><li>使用 http.Agent。用它来支持 keepAlive，关闭 Nagle 算法等等。</li><li>使用 stream.pipe()。相对于“接收-等待-发送”的模式，一方面主要是节省内存，另一方面可以减少等待，提高传输效率（但也不是绝对的）。</li></ul><p>不用安装第三方依赖，基于原生 http 写上十来行代码即可完工，所以我自己很喜欢直接用 http 做一些工作。</p><p>但如果代理需求变得复杂，使用现成的轮子才能利于队友们（也包括自己）维护。</p><h2 id="decompress"><a href="#decompress" class="headerlink" title="decompress"></a>decompress</h2><p>Got 默认对响应执行 decompress，对于代理而言毫无意义，需要关掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> _onResponseBase(response: IncomingMessageWithTimings): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;options&#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.decompress) &#123;</span><br><span class="line">    response = decompressResponse(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在 decompress 的文档上有说明，但是一点儿都不醒目。</p><blockquote><p>If this is disabled, a compressed response is returned as a Buffer. This may be useful if you want to handle decompression yourself or stream the raw compressed data.</p></blockquote><p>最坑的是，我是因为遇到了 stream 的 bug (<a href="https://github.com/sindresorhus/got/issues/1279" target="_blank" rel="noopener">#issues/1279</a>) 才注意到这个选项。在开启 decompress 的情况下，使响应值的 content-length 是错误的，该 bug 会导致返回的结果不完整。</p><h2 id="accept-encoding"><a href="#accept-encoding" class="headerlink" title="accept-encoding"></a>accept-encoding</h2><p>关闭 decompress 之后，响应开始变慢到肉眼可见得慢。</p><p>原因如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> _makeRequest(): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;options&#125; = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;headers&#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.decompress &amp;&amp; is.undefined(headers[<span class="string">'accept-encoding'</span>])) &#123;</span><br><span class="line">    headers[<span class="string">'accept-encoding'</span>] = supportsBrotli ? <span class="string">'gzip, deflate, br'</span> : <span class="string">'gzip, deflate'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>accept-encoding 只在 decompress 为 true 的时候设置，否则无法享用 gzip 等压缩带来的优化。</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> got = <span class="built_in">require</span>(<span class="string">'got'</span>);</span><br><span class="line"><span class="keyword">const</span> HttpAgent = <span class="built_in">require</span>(<span class="string">'agentkeepalive'</span>);</span><br><span class="line"><span class="keyword">const</span> HttpsAgent = HttpAgent.HttpsAgent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sec = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> min = <span class="number">60</span> * sec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> supportsBrotli = process.versions.brotli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = got.extend(&#123;</span><br><span class="line">  agent: &#123;</span><br><span class="line">    http: <span class="keyword">new</span> HttpAgent(),</span><br><span class="line">    https: <span class="keyword">new</span> HttpsAgent(),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// content-length is not set correctly when streaming with decompress</span></span><br><span class="line">  <span class="comment">// #issues/1279</span></span><br><span class="line">  decompress: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// accept-encoding won't be set without decompress</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'accept-encoding'</span>: supportsBrotli ? <span class="string">'gzip, deflate, br'</span> : <span class="string">'gzip, deflate'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  timeout: &#123;</span><br><span class="line">    connect: <span class="number">3</span> * sec,</span><br><span class="line">    socket: <span class="number">2</span> * min,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这大概率不是最终版，立一个 flag，如果再遇到问题，就自己从头写一个专用于代理场景的 http 库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在过去，request 模块几乎是 Node.js 端的不二选择，可惜已被放弃维护。如今流行的模块虽然变多，但不意味着它们足够成熟，我还是倾向于专注 Node.js 端的那几个。&lt;/p&gt;
&lt;p&gt;需求越简单，选择越不重要。不过相较而言，Got 的接口设计看起来更友好，并且它是做到支持 Connection Timeout 和 Read Timeout 的少数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;见 &lt;a href=&quot;https://github.com/sindresorhus/got/#comparison&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sindresorhus/got/#comparison&lt;/a&gt; 的 Advanced timeouts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际用下来，还是遇到了坑，顺便扒了一眼 Got 的代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="Stream" scheme="http://claude-ray.com/tags/Stream/"/>
    
      <category term="HTTP" scheme="http://claude-ray.com/tags/HTTP/"/>
    
      <category term="proxy" scheme="http://claude-ray.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>如何管理桌面窗口</title>
    <link href="http://claude-ray.com/2020/12/23/window-manager/"/>
    <id>http://claude-ray.com/2020/12/23/window-manager/</id>
    <published>2020-12-23T12:49:53.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>想向同事分享窗口切换的一点心得，不小心写成一篇没什么营养的方法论。虽然主要还是讲窗口切换。</p><a id="more"></a><p><img src="/image/window-manager/loop.gif" alt="publish"></p><blockquote><p>图片未加速</p></blockquote><h2 id="什么是窗口管理"><a href="#什么是窗口管理" class="headerlink" title="什么是窗口管理"></a>什么是窗口管理</h2><p>如果你不知道什么是窗口管理，在开启话题之前，不妨先来确认一下窗口管理器和桌面环境的概念。</p><p>首先说桌面环境，翻译自 Desktop Environment，它负责为用户提供完整的操作界面，而不仅仅是狭义的“桌面部件”，还包括图标、窗口、工具栏、壁纸等等。</p><p>再说窗口管理器，Window Manager，它是上述桌面环境的一部分，关乎图形化应用的窗口的基本操作，主要为如何进行排列和切换。窗口管理器是桌面环境的一部分，甚至可以完全独立于桌面环境，只运行窗口管理器，从而节省硬件资源。它包含以下类型：</p><ul><li>Float 悬浮：不同窗口可以相互重叠，就像桌子上随意摆放的白纸一样（这里借用了 Archlinux Wiki 的比喻）。正是 MacOS 和 Windows 提供的模式。</li><li>Tiling 平铺：窗口不能重叠，而是像瓦片一样挨个摆放。</li><li>Dynamic 动态：兼顾上述两种模式，可以动态切换窗口放置方式。</li></ul><p>不同类型的窗口管理器提供了不同的窗口摆放方式，还提供了各自的窗口切换逻辑，其中“平铺”更倾向于使用键盘操作，如何选择，主要看个人口味。</p><p>虽然着重介绍了窗口管理器，但它不是今天的主角，我们应该跳出所有的运行环境，去发现真正的“窗口管理器”其实是使用者自己。</p><h2 id="排列方式"><a href="#排列方式" class="headerlink" title="排列方式"></a>排列方式</h2><p>窗口排列是一个答案无足轻重选择题，需要结合显示器的使用习惯作答。如果仅从思路上讲，相比手动排列，自动排列无疑是更好的选择，此时平铺类窗口管理器的优势就体现出来了。</p><p>然而，Linux 可以非常轻松地调换窗口管理器，在 MacOS 下可供的选择就不多了。<a href="https://github.com/koekeishiya/yabai" target="_blank" rel="noopener">yabai</a> 要求关闭 SIP，提高了安全风险，<a href="https://github.com/ianyh/Amethyst" target="_blank" rel="noopener">Amethyst</a> 功能较弱，好在轻量可控。如果放弃一点点平铺的功能性，可以选择 moom 这类辅助布局软件。考虑到本文不是工具推荐，也就不再介绍更多。</p><p>对使用小屏幕和习惯全屏的用户而言，绝大多数的使用场景是全屏，则没必要安装辅助工具。</p><h2 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h2><h3 id="操作背景"><a href="#操作背景" class="headerlink" title="操作背景"></a>操作背景</h3><p>按以下特征对号入座，目的是想让大家思考不同使用习惯之间的异同点。现在你的窗口管理习惯，是否适用于其他的用户呢？</p><p>窗口模式：</p><ul><li>全屏化</li><li>窗口化</li><li>最小化（隐藏）</li></ul><p>桌面分布：</p><ul><li>单显示器-单桌面：将所有开启的窗口放在同一个桌面下，不采用任何虚拟桌面。</li><li>单显示器-多桌面：（按照习惯）将不同的软件放在不同的虚拟桌面下。</li><li>多显示器-单桌面：和多桌面类似，但不采用虚拟桌面，每台显示器就是一个桌面。</li><li>多显示器-多桌面：各台显示器放置了不同的虚拟桌面，互相隔离。</li></ul><h3 id="操作习惯"><a href="#操作习惯" class="headerlink" title="操作习惯"></a>操作习惯</h3><ol><li>鼠标/触摸板</li><li>全局快捷键（系统默认）<ul><li>MacOS 可以使用 command+tab 和 command+` 切换，Linux、Windows 有 alt+tab</li><li>MacOS 可以使用 control+↑ 和手势操作，Linux、Windows 有 win、win+tab</li></ul></li><li>启动器：例如 MacOS 的 Spotlight、Alfred，Windows 的 Everything，Linux 的 rofi、dmenu 等等</li><li>全局快捷键（自定义）</li></ol><p>它们的区别：</p><ol><li>寻找(思考) -&gt; 移动(思考+操作) -&gt; 确认(操作)</li><li>寻找(操作+思考) -&gt; 确认(操作)</li><li>寻找(思考+肌肉记忆) -&gt; 确认(操作)</li><li>确认(思考+肌肉记忆)</li></ol><blockquote><p>肌肉记忆≈闭眼操作</p></blockquote><p>虽然存在很大的误差，但不难发现，桌面越复杂，操作复杂度的差距就越明显。</p><h2 id="如何自定义快捷键"><a href="#如何自定义快捷键" class="headerlink" title="如何自定义快捷键"></a>如何自定义快捷键</h2><p>两个代表性工具，MacOS Hammerspoon，Linux wmctrl。同事 MacOS 开发较多，因此以 Hammerspoon 为例。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> hyper = &#123;<span class="string">"cmd"</span>, <span class="string">"shift"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：打开或切换到浏览器</span></span><br><span class="line">hs.hotkey.bind(hyper, <span class="string">"C"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  hs.application.launchOrFocus(<span class="string">"/Applications/Google Chrome.app"</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：打开或切换到终端</span></span><br><span class="line">hs.hotkey.bind(hyper, <span class="string">"Return"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  hs.application.launchOrFocus(<span class="string">"/Applications/Alacritty.app"</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>假如一个应用开启了多个窗口，也可以通过窗口标题、序号进行精准切换。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 根据标题切换应用窗口</span></span><br><span class="line"><span class="comment">-- @param appTitle 系统 menu bar 左上角的标题</span></span><br><span class="line"><span class="comment">-- @param appName 安装目录的名称或绝对路径</span></span><br><span class="line"><span class="comment">-- @param winTitle 模糊匹配项目名，注意 .()[]+- 等字符需要转义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launchOrFocusWindow</span><span class="params">(appTitle, appName, winTitle)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> app = hs.application(appTitle)</span><br><span class="line">    <span class="keyword">if</span> app == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">      hs.application.<span class="built_in">open</span>(appName)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">local</span> windows = app:allWindows()</span><br><span class="line">      <span class="keyword">for</span> _, win <span class="keyword">in</span> <span class="built_in">pairs</span>(windows) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> found = <span class="built_in">string</span>.<span class="built_in">match</span>(win:title(), winTitle)</span><br><span class="line">        <span class="keyword">if</span> found ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">          win:focus()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      app:activate()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：VSCode 多开窗口的切换，给名为 "my-project" 的项目定制快捷键</span></span><br><span class="line">hs.hotkey.bind(hyper, <span class="string">"1"</span>, launchOrFocusWindow(<span class="string">"Code"</span>, <span class="string">"Visual Studio Code"</span>, <span class="string">"my%-project"</span>))</span><br></pre></td></tr></table></figure><blockquote><p>launchOrFocusWindow 参数有些奇葩，因为 hs.application.get 和 hs.application.open 分别需要 title、path，互不兼容（可能是 bug）。<br>不过 get 和 open 还同时支持 bundleID，我认为名称对普通用户更友好，但如果你知道怎么获取 bundleID，自然可以用它来统一此处的入参。</p></blockquote><p>利用丰富的 <a href="https://www.hammerspoon.org/docs" target="_blank" rel="noopener">API</a>，你还可以设计更多复杂的功能。</p><h2 id="如何设置更多快捷键"><a href="#如何设置更多快捷键" class="headerlink" title="如何设置更多快捷键"></a>如何设置更多快捷键</h2><p>全局快捷键极易引起冲突，譬如某狗输入法（别用）。为了避免这种烦恼，我们可以在 Hammerspoon 设置组合键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> hyper = &#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;</span><br></pre></td></tr></table></figure><p>可惜，并不是所有人的手都能成长为“八爪鱼”，腱鞘炎了解一下？我们尽可能把多个按键合并，同时注意减少小拇指的使用。</p><p>以 MacOS 为例，使用 Karabiner-Elements，将大拇指附近不需要的按键设置为 hyper，配置示例如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Change option key"</span>,</span><br><span class="line">  <span class="attr">"rules"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Change right_option to left_option + left_control + left_command if pressed with other keys, to escape if pressed alone."</span>,</span><br><span class="line">      <span class="attr">"manipulators"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">          <span class="attr">"from"</span>: &#123;</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"right_option"</span>,</span><br><span class="line">            <span class="attr">"modifiers"</span>: &#123;</span><br><span class="line">              <span class="attr">"optional"</span>: [</span><br><span class="line">                <span class="string">"any"</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"key_code"</span>: <span class="string">"left_option"</span>,</span><br><span class="line">              <span class="attr">"modifiers"</span>: [</span><br><span class="line">                <span class="string">"left_control"</span>,</span><br><span class="line">                <span class="string">"left_command"</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"to_if_alone"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"key_code"</span>: <span class="string">"escape"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按住右 option，等于同时按住了 option+control+command，还可以随手实现轻按一下等于 ESC 的效果。</p><p>别忘了，组合键可不止这三个，还可以再从键盘上选几个键，设为 option+control+command+shift 等等，从此再也不用担心自定义的键位不够用了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>排列窗口的方式很大程度取决于个人口味，自由度也非常高。窗口切换的操作具备更强的逻辑性，需要付出一定的成本。两者都可以提高工作效益，值得思考改进。但也必须承认，改进 Workflow 的边际效应明显，希望读完这篇文章的你，宁可什么都不做，也不要反复抉择。</p><p>最后，分享一下我目前的 MBP 使用习惯吧：极端的全屏使用者，彻底禁用 Dock，隐藏 Menu Bar，将通知和时间放在了 Touch Bar，每天享受沉浸式的屏幕体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想向同事分享窗口切换的一点心得，不小心写成一篇没什么营养的方法论。虽然主要还是讲窗口切换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="http://claude-ray.com/categories/Essay/"/>
    
    
      <category term="MacOS" scheme="http://claude-ray.com/tags/MacOS/"/>
    
      <category term="WindowManager" scheme="http://claude-ray.com/tags/WindowManager/"/>
    
      <category term="Workflow" scheme="http://claude-ray.com/tags/Workflow/"/>
    
  </entry>
  
  <entry>
    <title>SSR 页面 CDN 缓存实践</title>
    <link href="http://claude-ray.com/2020/07/03/ssr-cdn-cache/"/>
    <id>http://claude-ray.com/2020/07/03/ssr-cdn-cache/</id>
    <published>2020-07-03T11:38:57.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>SSR 是一项资源密集型任务，要抵抗更大流量、提供更快的服务，缓存是其中的必修课。</p><p>而 CDN 缓存——作为静态资源的首要支撑，适合武装到 SSR 页面吗？</p><a id="more"></a><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>大家对 CDN 应该已经耳熟能详，如果不甚了解也没关系，我们先通过一系列问答带诸位走近这个话题。</p><h3 id="为什么接入-CDN？"><a href="#为什么接入-CDN？" class="headerlink" title="为什么接入 CDN？"></a>为什么接入 CDN？</h3><p>抽象一个简单的请求链路，方便理解 CDN 的定位。</p><p>接入前：</p><p><img src="/image/ssr-cdn-cache/cdn1.png" alt="cdn1"></p><blockquote><p>用户 -&gt; Nginx -&gt; App Server</p></blockquote><p>接入后：</p><p><img src="/image/ssr-cdn-cache/cdn2.png" alt="cdn2"></p><blockquote><p>用户 -&gt; CDN -&gt; Nginx -&gt; App Server</p></blockquote><p>看似增加了一层传输成本，其实不然。</p><p>CDN 利用自身广大的服务器资源，能动态优化访问路由、就近提供访问节点，以更低延迟、更高带宽从源站获取数据，优化了网络层面的用户体验。</p><h3 id="为什么开启-CDN-缓存？"><a href="#为什么开启-CDN-缓存？" class="headerlink" title="为什么开启 CDN 缓存？"></a>为什么开启 CDN 缓存？</h3><p>开启前：浏览器 -&gt; CDN -&gt; Nginx -&gt; App Server1 -&gt; App Server2 -&gt; …</p><p>开启后：浏览器 &lt;-&gt; CDN</p><p>CDN 能够缓存用户请求到的资源，并且可以包含 HTTP 响应头。在下一次任意用户请求同样的资源时，用缓存的资源直接响应用户，节省了本该由源站处理的所有后续步骤。</p><p>更直观的表达，就是截短了请求链路。</p><p><img src="/image/ssr-cdn-cache/cdn3.png" alt="cdn3"></p><h3 id="如何开启-CDN-缓存？"><a href="#如何开启-CDN-缓存？" class="headerlink" title="如何开启 CDN 缓存？"></a>如何开启 CDN 缓存？</h3><p>在不考虑自研 CDN 的情况下，开启 CDN 缓存的步骤非常简单：</p><ol><li>域名接入 CDN 服务，同时针对路径启用缓存</li><li>在源站设置 Cache-Control 响应头，为了更灵活地控制缓存规则，但并不是必须</li></ol><h3 id="哪些服务可以开启-CDN-缓存？"><a href="#哪些服务可以开启-CDN-缓存？" class="headerlink" title="哪些服务可以开启 CDN 缓存？"></a>哪些服务可以开启 CDN 缓存？</h3><p>大部分网站都适合接入 CDN，但 SSR 页面只有满足一定条件才可以开启 CDN 缓存</p><ul><li>无用户状态</li><li>对时效性要求不高，至少能接受分钟级的延迟</li></ul><h3 id="怎样判断是否命中缓存？"><a href="#怎样判断是否命中缓存？" class="headerlink" title="怎样判断是否命中缓存？"></a>怎样判断是否命中缓存？</h3><p>不同 CDN 平台检测的方法略有不同，本质上都是判断响应头的标识字段。以腾讯 CDN 为例，响应头 X-Cache-Lookup 分别表示</p><ul><li>Hit From MemCache: 命中 CDN 节点的内存</li><li>Hit From Disktank: 命中 CDN 节点的磁盘</li><li>Hit From Upstream: 未命中缓存，回源</li></ul><img src="/image/ssr-cdn-cache/cdn-headers.png" alt="cdn-headers" style="zoom:50%;" /><p>如果该字段不存在，说明该页面没有配置 CDN，或未开启缓存。</p><h2 id="CDN-缓存优化"><a href="#CDN-缓存优化" class="headerlink" title="CDN 缓存优化"></a>CDN 缓存优化</h2><p>用来衡量缓存效果的重要指标是缓存命中率，在正式设置 CDN 缓存之前，我们再来了解几个提高缓存命中率的要点。这些要点也适合作为评估系统是否应该接入 CDN 缓存的标准。</p><h3 id="延长缓存时间"><a href="#延长缓存时间" class="headerlink" title="延长缓存时间"></a>延长缓存时间</h3><p>提高 Cache-Control 的时间是最有效的措施，缓存持续时间越久，缓存失效的机会越少。</p><p>即使页面访问量不大的时候也能显著提高缓存命中率。</p><p>需要注意，Cache-Control 只能告知 CDN 该缓存的时间上限，并不影响它被 CDN 提早淘汰。流量过低的资源，很快会被清理掉，CDN 用逐级沉淀的缓存机制保护自己的资源不被浪费。</p><h3 id="忽略-URL-参数"><a href="#忽略-URL-参数" class="headerlink" title="忽略 URL 参数"></a>忽略 URL 参数</h3><p>用户访问的完整 URL 可能包含了各种参数，CDN 默认会把它们当作不同的资源，每个资源又是独立的缓存。</p><p>而有些参数是明显不合预期的，例如，页面链接在微信等渠道分享后，末尾被挂上各种渠道自身设置的统计参数。平均到单个资源的访问量就会大大降低，进而降低了缓存效果。</p><p>CDN 支持后台开启 <code>过滤参数</code> 选项，来忽略 URL <code>?</code> 后面的参数。 此时同一个 URL 一律当作同一个资源文件。</p><p>在腾讯 CDN 中，忽略参数的功能无法针对某个 URL，仅支持整个域名生效，这让过滤参数成为了极具风险的操作。除非域名缓存专用，否则不建议开启这个选项，即便同域名内所有已接入 CDN 缓存的资源都不依赖 URL 参数，也不能保证将来不会因此踩坑。</p><h3 id="主动缓存"><a href="#主动缓存" class="headerlink" title="主动缓存"></a>主动缓存</h3><p>化被动为主动，才有可能实现 100% 的缓存命中率。</p><p>常用的主动缓存是资源预热，更适合 URL 路径明确的静态文件，动态路由无法交给 CDN 智能预热，除非依次推送具体的地址。</p><h2 id="代码演进"><a href="#代码演进" class="headerlink" title="代码演进"></a>代码演进</h2><p>谈过 CDN 缓存优化的几个要点，便可得知 CDN 后台的配置是需要谨慎对待的。我在实际操作中，也经过了几个阶段的调整，可毕竟具体配置方式取决于 CDN 服务商，因此本文不再深入讨论。</p><p>现在，我们要把目光转到代码层的演进了。</p><h3 id="一、掌控缓存"><a href="#一、掌控缓存" class="headerlink" title="一、掌控缓存"></a>一、掌控缓存</h3><p>代码配置有一个前提，即 CDN 后台需要开启读取源站 Cache-Control 的支持。</p><p>而后，只要简单地添加响应头，就能从运维手中接管设置 CDN 缓存规则的主动权。</p><p>以 Node.js Koa 中间件为例，全局的初始化版本如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">`max-age=300`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，上述代码的疏漏是非常多的。在 SSR 应用中，不太需要缓存所有的页面，这就要补充路径的判断条件。</p><h3 id="二、控制路径"><a href="#二、控制路径" class="headerlink" title="二、控制路径"></a>二、控制路径</h3><p>虽然 CDN 后台也可以配置路径，但配置方式乃至路径数量都有局限性，不如代码形式灵活。</p><p>假如我们只需要缓存 /foo 页面，就加入 if 判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">'/foo'</span>) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">`max-age=300`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这就陷入了第一个陷阱，一定要注意路由对 path 的处理。一般地，’/foo’ 和 ‘/foo/‘ 是两个独立的 path。可能因为 ctx.path === ‘/foo’ 而漏掉了请求 path 为 /foo/ 的处理。</p><h3 id="三、补充路径"><a href="#三、补充路径" class="headerlink" title="三、补充路径"></a>三、补充路径</h3><p>伪代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ([ <span class="string">'/foo'</span>, <span class="string">'/foo/'</span> ].includes(ctx.path)) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">`max-age=300`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外，CDN 后台的配置也需要规避这个问题。在腾讯 CDN 中，目录和文件适用于不同的页面路径。</p><h3 id="四、忽略降级页面"><a href="#四、忽略降级页面" class="headerlink" title="四、忽略降级页面"></a>四、忽略降级页面</h3><p>在服务端渲染失败时，为了提高容错，我们会返回降级之后的页面，转为客户端渲染。如果因为偶然的网络波动，导致 CDN 缓存了降级页面，将在一段时间内持续影响用户体验。</p><p>所以我们又引入了 ctx._degrade 自定义变量，标识页面是否触发了降级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> ([ <span class="string">'/foo'</span>, <span class="string">'/foo/'</span> ].includes(ctx.path)) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">`max-age=300`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面降级时，取消缓存</span></span><br><span class="line">  <span class="keyword">if</span> (ctx._degrade) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没错，这并不是最后一个陷阱。</p><h3 id="五、Cookie-和状态治理"><a href="#五、Cookie-和状态治理" class="headerlink" title="五、Cookie 和状态治理"></a>五、Cookie 和状态治理</h3><p>上面已经提到了 CDN 可以选择性地缓存 HTTP 响应头，可是此选项是对整个域名生效，又普遍需要开启。</p><p>新的问题正是来自一个不希望被缓存的响应头。</p><p>应用 Cookie 的设置依赖于响应头 Set-Cookie 字段，Set-Cookie 的缓存直接会导致所有用户的 Cookie 被刷新为同一个。</p><p>有多个解决方案，一是该页面不要设置任何 Cookie，二是代理层过滤掉 Set-Cookie 字段。可惜腾讯 CDN 目前还不支持对响应头的过滤，这步容错必须自己操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> enableCache = [ <span class="string">'/foo'</span>, <span class="string">'/foo/'</span> ].includes(ctx.path)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">`max-age=300`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 页面降级时，取消缓存</span></span><br><span class="line">  <span class="keyword">if</span> (ctx._degrade) &#123;</span><br><span class="line">    ctx.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存页面不设 Set-Cookie</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (enableCache) &#123;</span><br><span class="line">    ctx.res.removeHeader(<span class="string">'Set-Cookie'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面增加的代码旨在页面响应前移除 Set-Cookie，但是中间件的加载顺序是难以控制的。特别是一些（中间件）插件，会隐式地创建 Cookie，这让 Cookie 的清理工作异常麻烦。如果后续维护人员不知情，很可能将 Set-Cookie 重新加入到响应头中。所以，这种擦屁股的工作，尽量在代理层处理，而不是放在代码逻辑中。</p><p>除了 Cookie，还可能面临其他状态信息管理问题。比如在 Vuex 的 renderState 中存放请求用户的登录状态，此时 HTML 页面嵌入了用户信息，如果被 CDN 缓存，在客户端将发生和未清除 Set-Cookie 相似的问题。类似的例子还有很多，它们的解决思路非常相像，接入 CDN 缓存前务必对状态信息做好全面的排查。</p><h3 id="六、定制缓存路径"><a href="#六、定制缓存路径" class="headerlink" title="六、定制缓存路径"></a>六、定制缓存路径</h3><p>现在功能总算趋于正常，然而缓存规则复杂多变，如果想设置更多页面，还要单独定制缓存时间呢？这段代码仍需要不断地变动。</p><p>例如，我们只想缓存 /foo/:id，而不缓存 /foo/foo、/foo/bar 等路径。</p><blockquote><p>注意 CDN 后台可能只支持配置一个 /foo/ 开头的缓存路径，这就要求我们需要将 ctx.set(‘Cache-Control’, ‘no-cache’) 做为默认处理，加在中间件的第一行。</p></blockquote><p>又比如，我们想缓存 /foo 页面 5 分钟，/bar 页面 1 天，又需要引入一个时间配置表。</p><p>这个中间件和相应的配置就会变得越来越难以维护。</p><p>因此，我们换一种思路，缓存规则不再交给中间件，而是转到 Vue SSR 的 entry-server，通过 metadata 可以做到页面级别的配置。由于 SSR 方案的差异性，不再赘述具体实现。</p><h3 id="七、缓存失效"><a href="#七、缓存失效" class="headerlink" title="七、缓存失效"></a>七、缓存失效</h3><p>缓存失效是个中性词，如何处理 CDN 缓存失效，此中利弊不得不慎重权衡。</p><p>一方面，它会间歇增加服务压力，在 Serverless 应用中还会提高计算成本。而另一方面，许多场景我们不得不主动触发它，才能真正更新资源。</p><p>CDN 缓存的黑暗面无法让人忽视。对用户而言，缓存是透明的，对产品、技术却很可能成为阻碍。</p><p>如果处理不当，它将影响新功能能否及时发布、阻断后置所有服务的埋点、提高风险感知的成本，以及无法保障一致性，增加了线上问题的排查难度。</p><p>因此，十分有必要设立一个负责缓存刷新、预热的触发式服务，用以改进开发人员的体验。可是 CDN 缓存可控性很低，刷新也不能做到全然实时生效。</p><p>处于频繁变化的页面，最好考虑进入稳定期再开启 CDN 缓存。即使是稳定的、大流量的页面，也还需要考虑 CDN 缓存穿透的防范措施。</p><p>一旦 CDN 缓存在 SSR 架构中得到重用，就要做好长期调整决策的准备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CDN 缓存是一把利刃，在大流量的场景下，可以替源站拦截几乎所有的请求，能提供极强伸缩性的负载。</p><p>那么 SSR 应用适合接入 CDN 缓存吗？再一次细数上面提到的诸多问题…</p><ul><li>路径控制</li><li>页面降级</li><li>状态治理</li><li>缓存失效</li></ul><p>答案得你自己说了算。</p><p>实际上，极少数 SSR 页面场景才需要 CDN 缓存，如门户首页。</p><p>流量不高、路径分散的一般业务，只需要使用动态的 CDN 加速和静态文件缓存，就能基本满足 CDN 代理层的优化需要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSR 是一项资源密集型任务，要抵抗更大流量、提供更快的服务，缓存是其中的必修课。&lt;/p&gt;
&lt;p&gt;而 CDN 缓存——作为静态资源的首要支撑，适合武装到 SSR 页面吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Architect" scheme="http://claude-ray.com/categories/Architect/"/>
    
    
      <category term="SSR" scheme="http://claude-ray.com/tags/SSR/"/>
    
      <category term="CDN" scheme="http://claude-ray.com/tags/CDN/"/>
    
      <category term="Cache" scheme="http://claude-ray.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>从 is-promise 事件我们可以学到什么</title>
    <link href="http://claude-ray.com/2020/05/16/npm-is-promise/"/>
    <id>http://claude-ray.com/2020/05/16/npm-is-promise/</id>
    <published>2020-05-16T11:35:30.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>4 月 25 日，NPM 社区又一次因更新事故引燃技术圈的讨论，导火索便来自名为 is-promise 的包。</p><p>网上盛传一个单行代码的包影响到了谷歌、FaceBook、亚马逊等众多大咖的知名项目，也有人扬言它使几乎整个 JavaScript 生态陷入了混乱。</p><p>不过“雪崩”之时，我和身边人都没有体会到震感，不禁疑惑，平时很少有场景需要判断某个值是否为 Promise，如此名声不显、功能又不重要的 NPM 包，真的有这么大的影响和破坏力吗？</p><p>既是好奇心的驱使，也是不认同部分夸张的言辞，我决定向前一探究竟。</p><a id="more"></a><h2 id="is-promise-简介"><a href="#is-promise-简介" class="headerlink" title="is-promise 简介"></a>is-promise 简介</h2><p>先解读一下事故发生之前，is-promise 2.1.0 版本的完整代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = isPromise;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!obj &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; <span class="keyword">typeof</span> obj.then === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个比较宽松的 Promise Like 检查函数，虽然包名叫 is-promise，其实更像 is-thenable。别看只有一行的逻辑，需要不浅的功力才能准确写出。</p><p>例如，前置的 <code>typeof</code> 能有效过滤 <code>String.prototype.then = function () {}</code> 这样不合规范的 thenable 字符串。</p><p>我们可以不使用，但不该贬低这个包的价值。Promise/A+ 是一个自由的规范，而非语言特性，长久以来有着众多版本实现，采取这种具有包容性的判断方式是合情合理的。</p><p>类似的 NPM 包还有 Sindre Sorhus 的 p-is-promise，它增加了 catch 方法的检查。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>让我们一起回到那个周末，重新审视整个事件的始末。</p><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><p>is-promise 作者 Forbes Lindesay 回顾了当时的主要历程：</p><p>2020–04–25T15:03:25Z — 发布存在问题的 2.2.0<br>2020–04–25T17:16:00Z — Ryan Zimmerman 提交了修复 <a href="https://github.com/then/is-promise/pull/15" target="_blank" rel="noopener">PR</a><br>2020–04–25T17:48:00Z — 在社交软件上收到告警<br>2020–04–25T17:54:00Z — 合并 Ryan 的 PR，发布 2.2.1<br>2020–04–25T17:57:00Z — 阅读并关闭 BUG 相关的 issues，重新开了一帖以便集中<a href="https://github.com/then/is-promise/issues/20" target="_blank" rel="noopener">沟通</a><br>2020–04–25T18:06:00Z — Jordan Harband 提到 “exports” 字段仍然存在<a href="https://github.com/then/is-promise/issues/20#issuecomment-619418975" target="_blank" rel="noopener">问题</a><br>2020–04–25T18:08:08Z — 从 package.json 中移除 “exports” 字段，发布 2.2.2<br>2020–04–25T19:20:00Z — 撤销 2.2.0 和 2.2.1</p><p>可见，作者收到告警信息后的反应是非常迅速的，但撤销操作滞后的问题仍需要指责。</p><p>接下来，我们逐个分析 2.2.x 版本的更迭。</p><h3 id="2-2-0"><a href="#2-2-0" class="headerlink" title="2.2.0"></a>2.2.0</h3><ul><li>添加 Typescript 声明文件</li><li>支持 ES Module 风格的 import</li></ul><p>站在上帝视角，我们明确知道问题出在这里，作者在 package.json 中新增了两个字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"import"</span>: <span class="string">"index.mjs"</span>,</span><br><span class="line">    <span class="attr">"require"</span>: <span class="string">"index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快，就有人反馈 BUG，一共有两类报错</p><p>错误一：exports 的文件路径遗漏了 ‘./‘，在 Node.js 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error [ERR_INVALID_PACKAGE_TARGET]: Invalid &quot;exports&quot; main target &quot;index.js&quot; defined in the package config &#x2F;xxx&#x2F;node_modules&#x2F;is-promise&#x2F;package.json; targets must start with &quot;.&#x2F;&quot;</span><br></pre></td></tr></table></figure><p>错误二：添加了 <code>type: module</code>，导致 require 被禁用，必须使用 import 才能引入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: &#x2F;xxx&#x2F;node_modules&#x2F;is-promise&#x2F;index.js</span><br></pre></td></tr></table></figure><p>以及被隐藏的错误三：没有更新 package.json 中的 files 字段，导致 index.mjs、index.d.ts 没有一起打包发布。</p><h3 id="2-2-1"><a href="#2-2-1" class="headerlink" title="2.2.1"></a>2.2.1</h3><ul><li>修复错误的 ESM 用法</li></ul><p>改动后的 package.json 包含如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"import"</span>: <span class="string">"./index.mjs"</span>,</span><br><span class="line">    <span class="attr">"require"</span>: <span class="string">"./index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，如果使用 require(‘is-promise/package.json’) 引入模块下其他文件，则会抛出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error [ERR_PACKAGE_PATH_NOT_EXPORTED]: Package subpath &#39;.&#x2F;package.json&#39; is not defined by &quot;exports&quot; in &#x2F;Users&#x2F;claude&#x2F;Workspace&#x2F;test&#x2F;is-p&#x2F;node_modules&#x2F;is-promise&#x2F;package.json</span><br></pre></td></tr></table></figure><p>甚至不允许引用 ‘is-promise/index’ 和 ‘is-promise/index.js’。</p><h3 id="2-2-2"><a href="#2-2-2" class="headerlink" title="2.2.2"></a>2.2.2</h3><ul><li>从 package.json 删除 exports 字段</li></ul><p>为了彻底解决 2.2.0 带来的 Breaking Change，终于在 2.2.2 删掉了 exports 字段。</p><h3 id="问题字段解析"><a href="#问题字段解析" class="headerlink" title="问题字段解析"></a>问题字段解析</h3><p>本次事故源于两个少见的 package.json 字段，我们已经见识到了其副作用，但还没搞明白为什么会被作者引入，不妨进一步明确它们的概念。</p><p>官网文档在 12.x 及以上版本都包含这些字段的描述，但是并不代表 12.x 用户一定享受到了这个特性。</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>它决定当前 package.json 层级目录内文件遵循哪种规范，包函两种值，默认为 commonjs。</p><ul><li>commonjs: js 和 cjs 文件遵循 CommonJS 规范，mjs 文件遵循 ESM 规范</li><li>module: js 和 mjs 文件遵循 ESM 规范，cjs 文件遵循 CommonJS 规范</li></ul><p>要正常使用这个特性，在 Node.js v12.x 的早期版本，必须主动开启 –experimental-modules。但是从 v12.16.0 以后就有些混乱，不开启选项的情况下错误使用该字段会立即抛出异常。直到了 v13.2.0 正式引入，取消了实验特性的标识，才算恢复正常。</p><p>is-promise 将 type 显式指定为 module，显然会影响到特定版本的 CommonJS 用户。</p><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p><code>type</code> 是相对较老的特性，<code>exports</code> 则是鲜有人知。</p><p>功能来自 <a href="https://github.com/jkrems/proposal-pkg-exports" target="_blank" rel="noopener">proposal-pkg-exports</a> 提案，以实验特性 –experimental-exports 加入 v12.7.0，于 v12.16.0 正式引入。具体时间线可以通过这个 <a href="https://github.com/nodejs/node/pull/29867" target="_blank" rel="noopener">PR</a> 追溯。</p><p>下面看它的具体作用。</p><p>通常，我们用 main 字段指定包的入口文件，但也仅限于指定唯一的入口文件。</p><p>exports 字段是 main 的补充，支持定制不同运行环境、不同引入方式下的入口文件，也支持导出其他文件，看下面的例子便知。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./main.js"</span>,</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"."</span>: <span class="string">"./main.js"</span>,</span><br><span class="line">    <span class="attr">"./feature"</span>: &#123;</span><br><span class="line">      <span class="attr">"browser"</span>: <span class="string">"./feature-browser.js"</span>,</span><br><span class="line">      <span class="attr">"default"</span>: <span class="string">"./feature.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但值得注意的是，在支持 exports 的 Node.js 版本中，exports 会覆盖 main.js。</p><p>exports 一旦被指定，只能引用 exports 中显示导出的文件。</p><p>用下面这种特殊写法，才能允许项目内所有文件被导出（未经过充分测试）。<br>但缺点是无法使用 <code>import isPromise from &#39;is-promise/index’</code>，而必须带上文件后缀 <code>import isPromise from &#39;is-promise/index.mjs&#39;</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exports"</span>: &#123;</span><br><span class="line">    <span class="attr">"."</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"./"</span>: <span class="string">"./"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，作者想当然以为 exports 和 main 字段一样，支持省略 “./“，这在文档中并没有交代。</p><h3 id="作者复盘"><a href="#作者复盘" class="headerlink" title="作者复盘"></a>作者复盘</h3><p>事后，作者发布了一篇 <a href="https://medium.com/javascript-in-plain-english/is-promise-post-mortem-cab807f18dcc" target="_blank" rel="noopener">《is-promise post mortem》</a>，他公开说明了上述的一部分错误，还总结了致使犯错的几个因素</p><ul><li>习惯于本地发布，不经过 CI 验证</li><li>使用新特性，CI 却没有添加支持新特性的 Node 版本</li><li>只验证了代码，没有验证实际发布到 NPM 的包</li><li>本人不在，其他维护者没有途径发布修复补丁</li></ul><p>总结下来就两点，测试不充分，流程不规范。</p><h3 id="再谈影响"><a href="#再谈影响" class="headerlink" title="再谈影响"></a>再谈影响</h3><p>我翻找了相关 ISSUES，发现 <a href="https://github.com/facebook/create-react-app/issues/8896" target="_blank" rel="noopener">create-react-app</a>、<a href="https://github.com/angular/angular-cli/issues/17549" target="_blank" rel="noopener">@angular/cli</a>、<a href="https://github.com/firebase/firebase-tools/issues/2179" target="_blank" rel="noopener">firebase-tools</a> 等项目的确受到影响，具体表现则为安装、构建失败。</p><p>再回看 NPM 生态，is-promise 周下载量在千万级，存在直接引用关系的就有 766 个包（现只剩 561，受事故影响，许多包取消了引用），GitHub 显示依赖它的项目更是有 3.5m 之众。</p><p>从问题版本 2.2.0 发布，到 2.2.2 修复，历时约 3 个小时，考虑到 NPM 的缓存机制，实际影响时间会被拉长。</p><p>因此，它的影响范围的确很广，但实际没有那么夸张。</p><p>一方面，Node.js 12.16.0 以前的 LST 和更早版本才是主流，这些运行时可被认定为安全。</p><p>另一方面，遭到辐射的项目（大多为 CLI 工具）并不具备整个生态的代表性，也不会危及生产环境。</p><h2 id="旁观者的思考"><a href="#旁观者的思考" class="headerlink" title="旁观者的思考"></a>旁观者的思考</h2><p>看过了问题，也借此反思一下如何避免悲剧发生在自己身上吧。</p><h3 id="锁定版本"><a href="#锁定版本" class="headerlink" title="锁定版本"></a>锁定版本</h3><p>加锁可以 100% 避免本次意外，尤其面向应用开发者，这是一直在呼吁的工作，却很少真正落地。</p><p>不要吐槽 package-lock.json 会自己变，因为只有一个 lock 文件是不成气候的，如果 package.json 没有锁定版本，NPM 才会使用浮动的版本覆盖 package-lock.json。</p><p>但对于 NPM 包的开发者，除非是对稳定性有所要求的工具链、产品，还是不建议滥用版本锁定。如果所有的 NPM 包都这么做，一定会加大 node_modules 的混乱程度，也不利于及时享受到相关依赖的修复补丁，反而提高了维护难度。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试的重要性无须多言。</p><p>is-promise 的新增更改根本没有得到测试覆盖，甚至连 require 引入都会报错。除了开发者要完善 CI，NPM 是否也有提供内置检测服务的义务呢？</p><h3 id="该不该使用小型代码库"><a href="#该不该使用小型代码库" class="headerlink" title="该不该使用小型代码库"></a>该不该使用小型代码库</h3><p>小型库背后是众多开源人士的努力贡献，优质的文档、测试用例远超代码的原始价值。</p><p>is-promise 的问题不在于它有几行代码，并且代码逻辑没有变更。</p><p>个人认为，NPM 包开发者有必要减少依赖数量，应用开发者则可以自由决定。引用也好，套用也罢，但至少请给这些代码的作者和协议应有的尊重。</p><h3 id="文档不济"><a href="#文档不济" class="headerlink" title="文档不济"></a>文档不济</h3><p>2.2.0 这个版本号的使用是否得当，如果只从功能上看，它是向下兼容 2.1.0 的一次更新吗？</p><p>看过上面 exports 字段的介绍可以得知，它当然属于 Breaking Change，但 Node.js 文档的描写是模糊的，让 is-promise 的作者认为 exports 是无害的。</p><p>官网通篇没有一个警告字样，如果没有这次事故后才提交的 <a href="https://github.com/nodejs/node/pull/33074/files" target="_blank" rel="noopener">PR</a>，恐怕会有更多的人掉入坑中。</p><h3 id="Yarn-or-NPM"><a href="#Yarn-or-NPM" class="headerlink" title="Yarn or NPM"></a>Yarn or NPM</h3><p>曾经有不少人倾向于 Yarn 的机制，时至今日，Yarn 和 NPM 的差距已经大大收缩，两者都是不错的选择，我唯一建议是不要混合使用。</p><p><img src="/image/npm-is-promise/benchmark.svg" alt="publish"></p><blockquote><p>Yarn 的速度已经没有特别大的优势</p></blockquote><p>还有像 <a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener">PNPM</a> 这类致力于改进 NPM 生态的努力，值得我们持续关注。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当前仍在批判 NPM 生态的人群，大部分不会参与 JS 社区的建设，愿改善现状而贡献的更是凤毛麟角。</p><p>各位 NPM 用户无须危言耸听，人有失手，马有失蹄，只要规范流程，能够有效降低负面影响。</p><p>逆耳未必是忠言，希望更多有价值的声音能被发出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;4 月 25 日，NPM 社区又一次因更新事故引燃技术圈的讨论，导火索便来自名为 is-promise 的包。&lt;/p&gt;
&lt;p&gt;网上盛传一个单行代码的包影响到了谷歌、FaceBook、亚马逊等众多大咖的知名项目，也有人扬言它使几乎整个 JavaScript 生态陷入了混乱。&lt;/p&gt;
&lt;p&gt;不过“雪崩”之时，我和身边人都没有体会到震感，不禁疑惑，平时很少有场景需要判断某个值是否为 Promise，如此名声不显、功能又不重要的 NPM 包，真的有这么大的影响和破坏力吗？&lt;/p&gt;
&lt;p&gt;既是好奇心的驱使，也是不认同部分夸张的言辞，我决定向前一探究竟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
      <category term="is-promise" scheme="http://claude-ray.com/tags/is-promise/"/>
    
  </entry>
  
  <entry>
    <title>分享一个 npm dist-tag 的冷知识</title>
    <link href="http://claude-ray.com/2020/04/29/npm-initial-publish-with-beta-tag/"/>
    <id>http://claude-ray.com/2020/04/29/npm-initial-publish-with-beta-tag/</id>
    <published>2020-04-29T13:13:15.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>dist-tag 是广为 npm 包开发者所熟知的属性，如果不是今天碰到一个有趣的问题，我根本没想过拉它出来玩。</p><p>为了照顾不曾了解 dist-tag 的用户，我先用一句话介绍 —— dist-tag 是 npm 版本号的命名空间，而 latest 则是默认的命名空间。想必大家不会陌生 <code>npm install &lt;name&gt;@latest</code> 这样的用法吧。</p><p>更重要的是，除非 package.json 中有所指定，所有安装默认在 latest 空间下匹配版本号。而处在 latest 空间时，也不会去名为 beta 的 dist-tag 下查找版本号。</p><p>那么问题来了！设想一个 npm 包首次发布就使用 beta 作为 dist-tag，它可以被 <code>npm install &lt;name&gt;</code> 安装吗？</p><a id="more"></a><p>答案是肯定的。</p><p>我还发布了一个空白的 npm beta 包作为验证。</p><p><img src="/image/npm-dist-tag/publish.png" alt="publish"></p><p><img src="/image/npm-dist-tag/install.png" alt="install"></p><p>明明 beta 和 latest 属于不同的命名空间，为啥这里用 latest 就把 beta 装了？</p><p>原因很简单，npm 服务端在初始化一个包时，不论发布者使用了什么 dist-tag，都会同时把它添加到 latest 上。这的确是个不成文的 feature，甚至 Verdaccio 等私服方案也按此逻辑来实现了。</p><blockquote><p>为了不污染 npm 环境（或承接相应的骂名），上面测试发布的包已经被笔者下架了 :P</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dist-tag 是广为 npm 包开发者所熟知的属性，如果不是今天碰到一个有趣的问题，我根本没想过拉它出来玩。&lt;/p&gt;
&lt;p&gt;为了照顾不曾了解 dist-tag 的用户，我先用一句话介绍 —— dist-tag 是 npm 版本号的命名空间，而 latest 则是默认的命名空间。想必大家不会陌生 &lt;code&gt;npm install &amp;lt;name&amp;gt;@latest&lt;/code&gt; 这样的用法吧。&lt;/p&gt;
&lt;p&gt;更重要的是，除非 package.json 中有所指定，所有安装默认在 latest 空间下匹配版本号。而处在 latest 空间时，也不会去名为 beta 的 dist-tag 下查找版本号。&lt;/p&gt;
&lt;p&gt;那么问题来了！设想一个 npm 包首次发布就使用 beta 作为 dist-tag，它可以被 &lt;code&gt;npm install &amp;lt;name&amp;gt;&lt;/code&gt; 安装吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>从 Vimium 到 qutebrowser</title>
    <link href="http://claude-ray.com/2020/01/01/from-vimium-to-qutebrowser/"/>
    <id>http://claude-ray.com/2020/01/01/from-vimium-to-qutebrowser/</id>
    <published>2020-01-01T06:21:32.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>过去两年，不论我安装、切换到哪家浏览器，<del>除了已逝的 Vimperator</del>，Vimium 都是第一个安装的插件。</p><p>曾经偶然听闻 qutebrowser 大名，但得知它没有让我难以割舍的 Dark Reader 插件，因此擦肩而过。</p><p>然而 Vimium 的小缺陷屡屡挑衅我的耐心，直到真正开始使用 qutebrowser，终于让我下定了迁移的决心。</p><a id="more"></a><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Vimium 只是一个浏览器插件，Firefox 和 Chrome 均有支持，可以说在不破坏原有操作体验的同时，补充了一些键盘操作的效率提升。</p><p>可它的工作方式是页面注入式的，必须等当前页面完成初始加载后才能使用键盘操作，又有一些页面注定无法完成注入，例如浏览器自己的插件商店、配置页。</p><p>qutebrowser 则是一个 PyQt 实现的轻量 GUI 跨平台浏览器，默认基于 Chromium 内核，并专注于键盘操作。不论页面是否完成加载，都可以随时使用键盘做出强大快捷的操作。</p><p>可惜缺少插件系统，且对 inspector 的支持很差，Web 开发者们可能难以接受。</p><p>它们最大的相同点，当属两者的按键都是 Vim 风格。即使之前从未体验过的用户，看看键位图也能理解它们的差异了。</p><p><img src="/image/from-vimium-to-qutebrowser/vimium-cheatsheet.png" alt="vimium cheatsheet"></p><p><img src="/image/from-vimium-to-qutebrowser/qutebrowser-cheatsheet.png" alt="qutebrowser cheatsheet"></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>qutebrowser 自带离线文档，<code>:help</code> 即可快捷查看，深度使用的话，自然要过上几遍。<br>接下来，我会介绍几个要点信息，帮助其他感兴趣的 Vimium 用户无痛切换到 qutebrowser。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>qutebrowser 的配置管理十分方便，支持通过修改文件自定配置。</p><p>不仅可以用 yml 文件做基础定义，还能使用 python 满足更多的定制需要。因而更推崇直接使用 config.py 做配置管理，Linux 平台在 <code>~/.config/qutebrowser/config.py</code>，Mac <code>~/.qutebrowser/config.py</code>， Windows 是 <code>%APPDATA%/qutebrowser/config/config.py</code>。</p><p>如果一开始配置文件不存在，可执行 <code>:config-write-py</code> 初始化。另有可选参数 <code>--force</code>，强制用当前配置覆写磁盘文件。</p><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>qutebrowser 默认搜索引擎为 duckduckgo，但可以按需增加自己的常用配置。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c.url.searchengines = &#123;</span><br><span class="line">    <span class="string">'DEFAULT'</span>: <span class="string">'https://google.com/search?q=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'google'</span>: <span class="string">'https://google.com/search?q=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'duckduckgo'</span>: <span class="string">'https://duckduckgo.com/?q=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'github'</span>: <span class="string">'https://github.com/search?q=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'npm'</span>: <span class="string">'https://npmjs.com/search?q=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'baidu'</span>: <span class="string">'https://baidu.com/s?wd=&#123;&#125;'</span>,</span><br><span class="line">    <span class="string">'mijisou'</span>: <span class="string">'https://mijisou.com/search?q=&#123;&#125;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键位迁移"><a href="#键位迁移" class="headerlink" title="键位迁移"></a>键位迁移</h2><p>作为 Vimium 老用户，我保留了之前的使用习惯，修改如下键位，并参考 <a href="https://github.com/amosbird/serverconfig" target="_blank" rel="noopener">Amos Bird</a> 的配置，增加了在模式转换时自动切换中文输入法状态。这里使用的是 fcitx-remote，在 Mac 下，可以借助 <a href="https://github.com/xcodebuild/fcitx-remote-for-osx" target="_blank" rel="noopener">fcitx-remote-for-osx</a> 实现同样的效果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bindings for normal mode</span></span><br><span class="line">config.bind(<span class="string">'x'</span>, <span class="string">'tab-close'</span>)</span><br><span class="line">config.bind(<span class="string">'X'</span>, <span class="string">'undo'</span>)</span><br><span class="line">config.bind(<span class="string">'J'</span>, <span class="string">'tab-prev'</span>)</span><br><span class="line">config.bind(<span class="string">'K'</span>, <span class="string">'tab-next'</span>)</span><br><span class="line">config.bind(<span class="string">'d'</span>, <span class="string">'scroll-page 0 0.5'</span>)</span><br><span class="line">config.bind(<span class="string">'u'</span>, <span class="string">'scroll-page 0 -0.5'</span>)</span><br><span class="line">config.bind(<span class="string">'j'</span>, <span class="string">'scroll-page 0 0.1'</span>)</span><br><span class="line">config.bind(<span class="string">'k'</span>, <span class="string">'scroll-page 0 -0.1'</span>)</span><br><span class="line">config.bind(<span class="string">'i'</span>, <span class="string">'enter-mode insert ;; spawn fcitx-remote -t'</span>)</span><br><span class="line">config.bind(<span class="string">'gi'</span>, <span class="string">'hint inputs --first ;; spawn fcitx-remote -t'</span>)</span><br><span class="line">config.bind(<span class="string">'p'</span>, <span class="string">'open -- &#123;clipboard&#125;'</span>)</span><br><span class="line">config.bind(<span class="string">'P'</span>, <span class="string">'open -t -- &#123;clipboard&#125;'</span>)</span><br><span class="line">config.unbind(<span class="string">'gl'</span>)</span><br><span class="line">config.unbind(<span class="string">'gr'</span>)</span><br><span class="line">config.bind(<span class="string">'gj'</span>, <span class="string">'tab-move -'</span>)</span><br><span class="line">config.bind(<span class="string">'gk'</span>, <span class="string">'tab-move +'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Escape&gt;'</span>, c.bindings.default[<span class="string">'normal'</span>][<span class="string">'&lt;Escape&gt;'</span>] + <span class="string">' ;; fake-key &lt;Escape&gt; ;; clear-messages ;; jseval --quiet document.getSelection().empty()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bindings for insert mode</span></span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-a&gt;'</span>, <span class="string">'fake-key &lt;Home&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-e&gt;'</span>, <span class="string">'fake-key &lt;End&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-d&gt;'</span>, <span class="string">'fake-key &lt;Delete&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-h&gt;'</span>, <span class="string">'fake-key &lt;Backspace&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-k&gt;'</span>, <span class="string">'fake-key &lt;Ctrl-Shift-Right&gt; ;; fake-key &lt;Backspace&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-f&gt;'</span>, <span class="string">'fake-key &lt;Right&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-b&gt;'</span>, <span class="string">'fake-key &lt;Left&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-n&gt;'</span>, <span class="string">'fake-key &lt;Down&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Ctrl-p&gt;'</span>, <span class="string">'fake-key &lt;Up&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br><span class="line">config.bind(<span class="string">'&lt;Escape&gt;'</span>, <span class="string">'spawn fcitx-remote -t ;; leave-mode ;; fake-key &lt;Escape&gt;'</span>, mode=<span class="string">'insert'</span>)</span><br></pre></td></tr></table></figure><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p>通过 <code>c.content.proxy</code>，可以轻松配置自己的代理，支持 http 和 socks 协议。</p><p>为了简化配置过程，我使用了 <code>Privoxy</code> 做了 http PAC 代理，可以参考我在 Mac 平台的 <a href="https://github.com/Claude-Ray/dotfiles/blob/master/macos/privoxy.sh" target="_blank" rel="noopener">Shell 脚本</a>。</p><h2 id="窗口最大化"><a href="#窗口最大化" class="headerlink" title="窗口最大化"></a>窗口最大化</h2><p>绝大部分时间，我的浏览器是处于窗口最大化的。当然不是 Mac 原生的全屏，私以为那种另开一个桌面的全屏模式体验太差，不仅窗口切换动画时间长，也无法与别的任务窗口叠加，总有需要抄点东西的时候。</p><p>在 Mac 上，qutebrowser 的 title bar 实在是又丑又大，可以通过 <code>c.window.hide_decoration = True</code> 来关闭它。但至今还存在的一个问题是关闭 title bar 之后，无法再调整窗口大小。</p><p>即使在更改设置之前 qutebrowser 窗口处于最大化状态，hide_decoration 只能起到隐藏 title bar 的效果，体现到界面上就是残缺的一条空白。身为强迫症简直不能忍！</p><p>一番琢磨，终于找到了临时的解决办法：</p><ol><li>先把 hide_decoration 关掉，在浏览器上快捷执行 <code>:set window.hide_decoration false</code></li><li>再将浏览器全屏，对应指令 <code>:fullscreen</code></li><li>执行 <code>:set window.hide_decoration true</code></li><li>按 <code>Ctrl+Up</code> 或用手势操作进入 Mission Control 界面，将最大化的 qutebrowser 从新桌面中拖拽到原来的桌面</li><li>这时 qutebrowser 进入短暂的“无响应”阶段，用鼠标点击或滚动一下窗口的任意地方即可重新激活</li></ol><p>这样就获得了无边框最大化的 qutebrowser。经过检验，重启 qutebrowser，甚至重启系统之后均能保持窗口最大化。</p><p>我还加了 title bar 的热键简化操作（下面 Meta 实为 Command/Super）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.window.hide_decoration = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">config.bind(<span class="string">'&lt;Meta-Ctrl-f&gt;'</span>, <span class="string">'config-cycle window.hide_decoration false true'</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一个多星期的使用，qutebrowser 流畅的操作体验令我开怀不矣，现在彻底将它作为主力浏览器。</p><p>另一方面，它支持 insert 模式的按键定制，可以让我们在其他系统环境下，像 Mac 一样在浏览器中使用 Emacs-like 键位做行内编辑！</p><p>假如你之前从未使用过 Vim-like 的浏览器插件，可以先把 Vimium 装起来。即使键位需要一点时间适应，可它胜在有着极大的包容性——不存在模式切换，没有按键冲突，也就不用担心它会降低你既有的操作效率。</p><p>最后，我的配置都在自己的 <a href="https://github.com/Claude-Ray/dotfiles" target="_blank" rel="noopener">dotfiles</a> 仓库，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去两年，不论我安装、切换到哪家浏览器，&lt;del&gt;除了已逝的 Vimperator&lt;/del&gt;，Vimium 都是第一个安装的插件。&lt;/p&gt;
&lt;p&gt;曾经偶然听闻 qutebrowser 大名，但得知它没有让我难以割舍的 Dark Reader 插件，因此擦肩而过。&lt;/p&gt;
&lt;p&gt;然而 Vimium 的小缺陷屡屡挑衅我的耐心，直到真正开始使用 qutebrowser，终于让我下定了迁移的决心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="http://claude-ray.com/categories/Essay/"/>
    
    
      <category term="Vim" scheme="http://claude-ray.com/tags/Vim/"/>
    
      <category term="Browser" scheme="http://claude-ray.com/tags/Browser/"/>
    
      <category term="Equipment" scheme="http://claude-ray.com/tags/Equipment/"/>
    
  </entry>
  
  <entry>
    <title>Verdaccio 性能优化：单机 Cluster</title>
    <link href="http://claude-ray.com/2019/12/31/optimize-verdaccio-cluster/"/>
    <id>http://claude-ray.com/2019/12/31/optimize-verdaccio-cluster/</id>
    <published>2019-12-31T11:46:30.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将讨论如何解决 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a> 官方本地存储方案不支持 Cluster 的问题。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标题为什么叫单机 Cluster 呢？</p><p>因为多机 Cluster 已经无法使用默认的本地存储，必须配合一套新的存储方案，而官方只提供了 AWS 和 Google Cloud 的支持。这在国内已经是一道门槛，因此大概率是要用上其他云存储服务的，这意味着必须做一个 Verdaccio 插件实现必备的 add、search、remove、get 功能。</p><p>糟糕的是，倘若自己的云存储不支持查询功能，还得基于数据库再造一套轮子，甚至再加一套解决读写冲突的轮子。</p><p>一句话来说，Verdaccio 是轻量级好手，不适合也不必要承载太重的装备。重度使用的场景下，与其从头定制的存储体系，不如直接上 cnpm、Nexus 等体积更大、相对成熟的系统。</p><p>话说回来，作为尝试，我还是基于 Redis 实现了它的单机 Cluster。虽然修改的 Verdaccio 版本较旧，但其新版 V4 的架构并没有太大变化，思路还是一致的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Verdaccio 默认无法使用 PM2 Cluster 启动，有两大阻碍。</p><p>其一，缓存同步。它使用进程级别的内存缓存，没有实现进程间通讯，多进程之间缓存信息不能同步。</p><p>其二，写锁。本地存储将内容持久化到本机磁盘，只有进程级别的“锁”，多进程容易出现写文件冲突。</p><p>这两个问题处理起来其实非常简单，特别是引入 Redis 之后。</p><p>针对第一点，内存缓存可以迁移到 Redis，但是其中有大体积的 JSON 信息，不适合存在 Redis，可以用 Redis 做消息中心，管理各进程的缓存状态。</p><p>针对第二点，私服本身属于简单的业务场景，Redis 锁完全可以胜任。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>本应该是 Show Code 环节，可念在笔者改的版本不存在普适性，索性改成修改要点的简单罗列吧。</p><ul><li><p>重写 local storage，本地存储依赖一个叫 <code>.sinopia-db.json</code> 或 <code>.verdaccio-db.json</code> 的文件，其中保存所有私服的包。这个文件的内容适合使用 Redis 的 set 结构进行替换。</p></li><li><p>查找并替换所有 <code>fs.writeFile</code>，加锁处理。在锁的实现上，新手需要多看官方文档，大部分博客的实现都是错误的，比如忽略了解锁步骤的原子化操作。</p></li><li><p>向上回溯修改的链路。</p></li></ul><h2 id="额外的补充"><a href="#额外的补充" class="headerlink" title="额外的补充"></a>额外的补充</h2><p>想来这可能是专题的最后一期，于是把不太相关的几个小问题也堆到下面吧。</p><p>只关心 Cluster 改造的看官可跳过此节，直接看末尾总结。</p><h3 id="异步风格"><a href="#异步风格" class="headerlink" title="异步风格"></a>异步风格</h3><p>由于手上的 Verdaccio 版本较老，整体还是 callback 风格，让改造多了一点工作量。我使用的 Redis 客户端为 ioredis，注意把涉及到的调用链路都改造为 async/await。</p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>另一个坑点是我拿到的 Redis 其实是 Codis 集群，这套方案的一个缺点是无法使用 Redis 弱弱的发布订阅功能，也就不能直接拿来订阅更新内存缓存的消息。只好另辟蹊径，将 Redis 作为“缓存中心”，进程取缓存前先查询标志位，如果标志位存在，代表内存缓存需要更新。以进程号等信息做 key 前缀表示区分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheCenter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(prefixKey = 'updated') &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 利用 redis 缓存标志位，为空时表示缓存需要更新</span></span><br><span class="line">    <span class="keyword">this</span>.prefix = prefixKey;</span><br><span class="line">    <span class="comment">// 用 pm2 进程号区分缓存状态</span></span><br><span class="line">    <span class="keyword">this</span>.ip = getIPAddress();</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.ip&#125;</span>:<span class="subst">$&#123;process.env.NODE_APP_INSTANCE || <span class="number">0</span>&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> isCached = <span class="keyword">this</span>.data.has(key);</span><br><span class="line">    <span class="keyword">if</span> (isCached) &#123;</span><br><span class="line">      <span class="keyword">const</span> isCacheLatest = <span class="keyword">await</span> redis.hget(<span class="keyword">this</span>._key(key), <span class="keyword">this</span>.id);</span><br><span class="line">      <span class="keyword">if</span> (isCacheLatest) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.get(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">set</span>(key, value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.set(key, value);</span><br><span class="line">    <span class="keyword">await</span> redis.hset(<span class="keyword">this</span>._key(key), <span class="keyword">this</span>.id, <span class="built_in">Date</span>.now());</span><br><span class="line">    redis.expire(<span class="keyword">this</span>._key(key), <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> del(key) &#123;</span><br><span class="line">    redis.del(<span class="keyword">this</span>._key(key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.has(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _key(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.prefix&#125;</span>:<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIPAddress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> interfaces = os.networkInterfaces();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> iface <span class="keyword">of</span> <span class="built_in">Object</span>.values(interfaces)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> alias <span class="keyword">of</span> iface) &#123;</span><br><span class="line">      <span class="keyword">if</span> (alias.family === <span class="string">'IPv4'</span> &amp;&amp; alias.address !== <span class="string">'127.0.0.1'</span> &amp;&amp; !alias.internal) &#123;</span><br><span class="line">        <span class="keyword">return</span> alias.address;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'127.0.0.1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> CacheCenter();</span><br></pre></td></tr></table></figure><h3 id="页面搜索优化"><a href="#页面搜索优化" class="headerlink" title="页面搜索优化"></a>页面搜索优化</h3><p>顺便一提，Verdaccio web 页面的 /search 接口性能极差，实现也存在诸多问题。此处值得加一层内存缓存，等到新包发布时刷新。</p><p>早期 Verdaccio 不支持使用 name 搜索名为 @scope/name 的包，可增加一条 name 专用的索引字段促成改进。根源是依赖的 lunr 引擎版本过低（0.7.0），但最新 lunr 的表现依然不太理想。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = lunr(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.field(<span class="string">'name'</span>, &#123;<span class="attr">boost</span>: <span class="number">10</span>&#125;);</span><br><span class="line">      <span class="keyword">this</span>.field(<span class="string">'unscoped'</span>, &#123;<span class="attr">boost</span>: <span class="number">8</span>&#125;);</span><br><span class="line">      <span class="keyword">this</span>.field(<span class="string">'description'</span>, &#123;<span class="attr">boost</span>: <span class="number">4</span>&#125;);</span><br><span class="line">      <span class="keyword">this</span>.field(<span class="string">'author'</span>, &#123;<span class="attr">boost</span>: <span class="number">6</span>&#125;);</span><br><span class="line">      <span class="keyword">this</span>.field(<span class="string">'readme'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a new element to index</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>pkg the package</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  add(pkg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index.add(&#123;</span><br><span class="line">      id: pkg.name,</span><br><span class="line">      name: pkg.name,</span><br><span class="line">      unscoped: getUnscopedName(pkg.name),</span><br><span class="line">      description: pkg.description,</span><br><span class="line">      author: pkg._npmUser ? pkg._npmUser.name : <span class="string">'???'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截取包名中不带 scope 的部分</span></span><br><span class="line"><span class="comment"> * 参照命名规范 <span class="doctag">@scope</span>/name，直接截取/后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUnscopedName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.split(<span class="string">'/'</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为 Verdaccio 开启 Cluster 能力并不是一个轻松的做法，但经过这个系列解读，却可以轻松地作出选择。</p><p>如果只是想一定程度上提高处理高并发的性能，可以采取上一篇<a href="http://claude-ray.com/2019/10/22/optimize-verdaccio-proxy/">代理分流</a>的做法，代理可以帮你分担 99% 以上的压力。</p><p>如果想进一步提升性能，实现应用的平滑重启，本文单机 Cluster 并配合 pm2 reload 的做法不妨一试。</p><p>而一但想开启多节点集群的能力，几乎超出了轻量级私服的理念，试着迁移到 cnpm、Nexus 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇将讨论如何解决 &lt;a href=&quot;https://github.com/verdaccio/verdaccio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Verdaccio&lt;/a&gt; 官方本地存储方案不支持 Cluster 的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
      <category term="Verdaccio" scheme="http://claude-ray.com/tags/Verdaccio/"/>
    
      <category term="private npm registry" scheme="http://claude-ray.com/tags/private-npm-registry/"/>
    
  </entry>
  
  <entry>
    <title>让 npm install 不使用缓存的方法</title>
    <link href="http://claude-ray.com/2019/12/06/npm-install-without-cache/"/>
    <id>http://claude-ray.com/2019/12/06/npm-install-without-cache/</id>
    <published>2019-12-06T04:04:56.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>npm 的安装出错是屡见不鲜，往往是因为安装的环境不够 “clean”。</p><p>通常情况下，只要删除项目目录的 node_modules 和 package-lock.json，重新执行 install 就能解决。</p><p>偶尔也会出现上述操作解决不了的问题，譬如 npm 的缓存文件异常，就需要在安装前执行 <code>npm cache clean --force</code> 清空缓存目录。</p><p>但 npm cache clean 也存在两个未处理的缺陷，使它既不完全可靠又具备风险。</p><a id="more"></a><ol><li><p>部分依赖会和 npm 共用缓存目录（终端下通过 <code>npm config get cache</code> 命令查看，默认 <code>~/.npm</code>），用来存放自己的临时文件。</p><p> 而 npm@5 之后，cache clean 只会清除该缓存目录下的 <code>_cacahce</code> 子目录，而忽视不在该子目录的缓存。</p><p> 例如 @sentry/cli 将缓存放在了和 _cacache 同级的 <a href="https://github.com/getsentry/sentry-cli/blob/1.49.0/scripts/install.js#L78" target="_blank" rel="noopener">sentry-cli</a> 目录，clean cache 不会清除此处缓存。</p><blockquote><p>此例有网友专门记录了<a href="https://github.com/sliwey/blog/issues/1" target="_blank" rel="noopener">排错经过</a></p></blockquote></li><li><p>突然执行 cache clean，将导致正在使用 npm install 的项目丢失部分依赖。</p><p> 如果有多个项目在同一环境执行 npm install，此问题的影响会进一步扩大，npm 将抛出各种文件操作错误。</p></li></ol><p>鉴于缓存出错是极小概率事件，若能使用温和的安装方式避开缓存文件，无疑是更好的选择。</p><p>可是，npm install 利用缓存的行为是默认且强制的，目前官方还没有提供形如 –no-cache 的选项来做一次忽略缓存的干净安装。</p><blockquote><p>npm-cache 机制详见<a href="https://docs.npmjs.com/cli/cache.html" target="_blank" rel="noopener">官网文档</a></p></blockquote><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>尽管 npm cli 还没支持，但这个需求我们自己实现起来却十分简单。</p><p>既然 cache 目录是通过 npm config get cache 获取的，也就支持相应的 set 方式。为每个待安装项目重新配置 cache 目录，等于变相地清除了 npm 之前所有的缓存。</p><p>当然，直接 npm config set cache 会让 npm 全局生效，为了单独设置缓存目录，在项目内添加 .npmrc 文件，并加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache&#x3D;.npm</span><br></pre></td></tr></table></figure><p>可观察到缓存路径的变更生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get cache</span><br><span class="line">/Users/claude/.npm</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> ~/node-project &amp;&amp; <span class="built_in">echo</span> cache=.npm &gt;&gt; .npmrc</span><br><span class="line"></span><br><span class="line">$ npm config get cache</span><br><span class="line">/Users/claude/node-project/.npm</span><br></pre></td></tr></table></figure><p>再安装就会重新下载依赖啦，还起到了环境隔离的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h1&gt;&lt;p&gt;npm 的安装出错是屡见不鲜，往往是因为安装的环境不够 “clean”。&lt;/p&gt;
&lt;p&gt;通常情况下，只要删除项目目录的 node_modules 和 package-lock.json，重新执行 install 就能解决。&lt;/p&gt;
&lt;p&gt;偶尔也会出现上述操作解决不了的问题，譬如 npm 的缓存文件异常，就需要在安装前执行 &lt;code&gt;npm cache clean --force&lt;/code&gt; 清空缓存目录。&lt;/p&gt;
&lt;p&gt;但 npm cache clean 也存在两个未处理的缺陷，使它既不完全可靠又具备风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Verdaccio 性能优化：代理分流</title>
    <link href="http://claude-ray.com/2019/11/30/optimize-verdaccio-proxy/"/>
    <id>http://claude-ray.com/2019/11/30/optimize-verdaccio-proxy/</id>
    <published>2019-11-30T11:08:03.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里的 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a> 是指用于搭建轻量级 npm 私有仓库的开源解决方案，以下简称 npm 私服。</p><p>前段时间写了一点分流相关的<a href="http://claude-ray.com/2019/10/22/optimize-verdaccio-package-route/">优化思路</a>，但那是以节省资源开销为主、不冲破原有结构的微调，从结果上看，甚至不是合格的优化。</p><p>随着用户（请求）数量的上升，服务响应速度和效率其实才是最要紧的问题，节省资源终究不能改善这一点。因此我决定实施上次浮现在脑中的想法，将内外网的 npm 包流量彻底分流。</p><a id="more"></a><h3 id="关于-Cluster-模式的说明"><a href="#关于-Cluster-模式的说明" class="headerlink" title="关于 Cluster 模式的说明"></a>关于 Cluster 模式的说明</h3><p>再次解释，Verdaccio 官方文档明确表示不能支持（PM2）Cluster 模式。另外，其云存储方案是可以支持多进程多节点部署的，但只提供了 google cloud、aws s3 storage 的插件。</p><p>不过在此基础上，只要拥有自己的云存储服务，就能使用或设计一套新的存储插件，进而支持多进程架构。此方案一定可行，只是相比本篇的做法，需要的成本更高一些。</p><p>俗话说得好，没有一个中间层解决不了的问题，而在 Verdaccio 的场景下，这种做法又是相当地迅速和高效。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="npm-安装机制"><a href="#npm-安装机制" class="headerlink" title="npm 安装机制"></a>npm 安装机制</h3><p>如果不了解 npm 官方客户端的安装机制，稍后可以阅读阮一峰的博客[[<a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html][《npm" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/npm-install.html][《npm</a> 模块安装机制简介》]]，少部分知识已经不适用于当前版本了，不过最重要的是能理解 npm 下载流程。</p><p>其中我们需要知道，npm 包下载前，客户端会向上游服务器查询包信息，以及获取压缩包的下载地址 url，并将此 url 存放在 package-lock.json 文件中。以后每次执行下载，都会优先使用 package-lock.json 中的地址。</p><h3 id="npm-下载最长请求路径"><a href="#npm-下载最长请求路径" class="headerlink" title="npm 下载最长请求路径"></a>npm 下载最长请求路径</h3><p>为了方便理解 Verdaccio 所处的位置，我来绘制一下 npm 包下载时从客户端到 Verdaccio 再到上游的最长请求路径简图，并忽略中间的安全验证环节，如下所示。</p><p><img src="/image/optimize-verdaccio-proxy/verdaccio-fetch-path.png" alt="npm 请求路径"></p><h3 id="接口转发"><a href="#接口转发" class="headerlink" title="接口转发"></a>接口转发</h3><p>有了代理层，就可以忽略 Verdaccio 内部的各种逻辑，不受技术栈的约束，编写少量的代码，便能完成主要接口的分流。</p><p>首要的接口是 <code>/:package/:version?</code> ，释放私服最大的查询压力，原因可以看<a href="http://claude-ray.com/2019/10/22/optimize-verdaccio-package-route">这里的解释</a>。</p><p>次要的接口是 <code>/:package/-/:filename</code> ，也就是实际的下载接口。并且其中还涉及另一个极为有利的优化。</p><p>尽管 Verdaccio 是转发上游的资源，它也会将下载 url 变更为自己的服务域名。因此不论依赖是否私有，记录到 package-lock.json 中的地址都是 Verdaccio 的地址。</p><p>但经过代理层的分流，此后经过更新的 package-lock.json 将保留原汁原味的下载地址，此后下载压缩包的请求再也不会发到私服。</p><p>综上所述，我们可以将私服超过 99.99% 的流量转移到代理或上游服务。</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>接下来，我们来确定分流口径，自然是判断一个 package 是否是私服私有，因此需要 Verdaccio 提供接口，获取私有包的列表。</p><p>Verdaccio 有一个 <code>/-/verdaccio/packages</code> 接口用来获取所有私有包的信息，但这个包主要用于 Web 页面，包含大量我们不需要的信息，甚至简单一点，只要提供私有 npm 包的包名就能满足筛选条件。</p><p>因此，可以改良 <code>/-/verdaccio/packages</code>，例如新增一个专门获取包名列表的接口，并增加内存缓存。</p><p>Verdaccio 版本不同时，做法也有很大差异，相信这里的处理不是问题，只要认真阅读上述接口就能获取思路了。</p><p>PS：还是补充一点代码吧，早期版本 Verdaccio 只需要这样改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get name list of all visible package</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@route </span>/-/verdaccio/names</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">route.get(<span class="string">'/names'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处 cache 作为缓存，在有新的私有 npm 包发布时刷新即可</span></span><br><span class="line">  <span class="keyword">let</span> names = cache.get(<span class="string">'packageNames'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!names) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      names = <span class="keyword">await</span> storage.localStorage.localList.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.set(<span class="string">'packageNames'</span>, names);</span><br><span class="line">  &#125;</span><br><span class="line">  next(names);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最新的 names 要使用回调的方式取值，伪代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">  storage.localStorage.storagePlugin.get(<span class="function">(<span class="params">err, list</span>) =&gt;</span></span><br><span class="line">    err ? reject(err): resolve(list)))</span><br></pre></td></tr></table></figure><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端也能承担分流的任务，即像 cnpm 一样包装一层自己的 npm cli 工具，但分流的逻辑要简单许多，只需检查要安装的包是否属于私有，然后分为两批安装。</p><p>缺陷是推行难度和速度都不理想，于是这里只是顺便提一下。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>到这一步，技术选型已经无所谓了，自然可以 nginx + lua，简单一点就继续使用 Node.js 实现。</p><p>由于其他原因，我用 express 做了实现，贴一点转发逻辑，大家就自由发挥吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise-native'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicRegistry = <span class="string">'http://registry.npm.taobao.org'</span>;</span><br><span class="line"><span class="keyword">const</span> privateRegistry = <span class="string">'http://npm.private.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sec = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> min = <span class="number">60</span> * sec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateListCache = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查并更新私服包名列表的缓存</span></span><br><span class="line"><span class="comment"> * 缓存可以基于 redis 或内存，注意控制好更新节奏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPrivateCache</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * npm package 请求分流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@route </span>/:packages/:version?   版本检查</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@route </span>/:packages/-/:filename 下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">packages</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line">  <span class="keyword">await</span> checkPrivateCache();</span><br><span class="line">  <span class="comment">// 请求默认转发至 taobao</span></span><br><span class="line">  <span class="keyword">let</span> baseUrl = publicRegistry;</span><br><span class="line">  <span class="keyword">if</span> (privateListCache.length &amp;&amp; privateListCache.includes(req.params.package)) &#123;</span><br><span class="line">    <span class="comment">// 转发私服的请求</span></span><br><span class="line">    baseUrl = privateRegistry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    uri: baseUrl + req.url,</span><br><span class="line">    timeout: <span class="number">2</span> * min</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    request(options).on(<span class="string">'error'</span>, next).pipe(res)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其他请求原样转发私服</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@route </span>/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清除 headers 的 host</span></span><br><span class="line">  <span class="keyword">const</span> headers = <span class="built_in">Object</span>.assign(&#123;&#125;, req.headers, &#123; <span class="attr">host</span>: <span class="literal">undefined</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    uri: privateRegistry + req.url,</span><br><span class="line">    method: req.method,</span><br><span class="line">    timeout: <span class="number">2</span> * min,</span><br><span class="line">    headers</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    req.pipe(request(options).on(<span class="string">'error'</span>, next)).pipe(res);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在同样的测试条件下，私服的 /:package/:version? 接口平均响应耗时从 4s 降至 400 ms，可以明显感觉到速度的提升，并且可以通过不断扩展代理层优化处理效率。作为轻量级的私服解决方案，已经可以续命很久了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这个系列就此结束了吗？<del>当然没有，cluster 的坑还没填呢！</del>也确实可能会鸽掉…</p><p>因为支持 cluster 需要较深入的二次开发，也有新的中间件引入，相比目前的成本要高出不少。并且 Verdaccio 新旧版本的逻辑存在一定差异，我在老版本中已经解决了此问题，但新版可能又要另一套实现。</p><p>所以，等我读完 Verdaccio 最新的代码再说吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这里的 &lt;a href=&quot;https://github.com/verdaccio/verdaccio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Verdaccio&lt;/a&gt; 是指用于搭建轻量级 npm 私有仓库的开源解决方案，以下简称 npm 私服。&lt;/p&gt;
&lt;p&gt;前段时间写了一点分流相关的&lt;a href=&quot;http://claude-ray.com/2019/10/22/optimize-verdaccio-package-route/&quot;&gt;优化思路&lt;/a&gt;，但那是以节省资源开销为主、不冲破原有结构的微调，从结果上看，甚至不是合格的优化。&lt;/p&gt;
&lt;p&gt;随着用户（请求）数量的上升，服务响应速度和效率其实才是最要紧的问题，节省资源终究不能改善这一点。因此我决定实施上次浮现在脑中的想法，将内外网的 npm 包流量彻底分流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
      <category term="Verdaccio" scheme="http://claude-ray.com/tags/Verdaccio/"/>
    
      <category term="private npm registry" scheme="http://claude-ray.com/tags/private-npm-registry/"/>
    
  </entry>
  
  <entry>
    <title>Verdaccio 性能优化：上游路径转发</title>
    <link href="http://claude-ray.com/2019/10/22/optimize-verdaccio-package-route/"/>
    <id>http://claude-ray.com/2019/10/22/optimize-verdaccio-package-route/</id>
    <published>2019-10-22T11:32:39.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这里的 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a> 是指用于搭建轻量级 npm 私有仓库的开源解决方案，以下简称 npm 私服。</p><p>近期观察发现，有些项目依赖了名为 <code>npm</code> 的 npm 包，每次项目部署时都会向私服 <code>/npm</code> 发起请求记录，并在监控曲线上呈明显的高耗时，这引起了我们的关注。</p><p>有些项目依赖了 npm 自身的包，每次项目部署时都会产生对私服 <code>/npm</code> 路由的请求记录，并在监控曲线上呈明显的高耗时，这引起了我们的关注。</p><a id="more"></a><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Verdaccio 对公共（外网）npm 包的中转存在不小的性能损耗。</p><p>其中一个问题，通过私服下载未经缓存的公共 npm 包，Verdaccio 都要等上游镜像的响应完整结束之后，才开始响应私服用户的请求。这导致 Verdaccio 的整体速度比直接用上游慢了一截。</p><p>至于会慢多少呢，要提到另一个 npm 机制：一个依赖 package 下载之前，要先到镜像地址的 =/:package/:version?= 接口获取完整的包信息，之后才会下载所需的版本。而一个模块历史发布过的版本越多，信息量越大。尤其是 npm 自身这个包，访问一下 <a href="http://registry.npmjs.org/npm" target="_blank" rel="noopener">http://registry.npmjs.org/npm</a> 便知。</p><p>Verdaccio 慢就慢在获取包信息这一步，它必须等待上游接口响应完成，才能做相关 JSON 解析和逻辑处理。因此不仅仅是慢的问题了，还有内存和 CPU 的大量消耗。</p><p>然而这一步对于 Verdaccio 又很重要，因为它的对于此接口的缓存策略基于文件，只有拿到完整的 JSON 返回值才能将其记录到文件中。只是默认仅 2 分钟的缓存时间，让这一步操作的性价比打了折扣。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从上面看，私服接口性能优化空间还很大，哪怕只是将几个体积较大的“罪魁祸首” npm 包单独优化，也能缓解私服的压力。</p><p>首先想到的是让 Verdaccio 不必等待上游全部返回就开始响应私服用户。其次是现有的缓存机制对部分低频率高开销的 package 请求形同虚设，小机器又经不起缓存扩充的资源消耗，网络带宽倒是相对不缺，降低计算成本、纯网络代理转发是一个可行的方向。</p><p>Verdaccio 会对下载的 npm 包信息做解析和记录，但其实我们并不关心那些只属于上游的包，只希望它能承担好转发工作，甚至所有公共依赖都不经过私服处理。</p><p>退一步讲，就是要弱化在私服中对这些公共依赖的处理，减少解析过程 —— 用 stream 或 buffer 完成请求转发。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>遗憾的是 Verdaccio 自身的接口难以复用，只好直接在其基础上增加路由(中间件)。简单粗暴，对项目的熵值影响不大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">const</span> createError = <span class="built_in">require</span>(<span class="string">'http-errors'</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> URL = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Middleware = <span class="built_in">require</span>(<span class="string">'../../web/middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> Utils = <span class="built_in">require</span>(<span class="string">'../../../lib/utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">route, auth, storage, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> can = Middleware.allow(auth);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化特定依赖的获取，以 `npm` 举例</span></span><br><span class="line">  route.get(<span class="string">'/npm'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拼接镜像地址</span></span><br><span class="line">    <span class="keyword">const</span> upLinkUrl = _.get(config, <span class="string">'uplinks.npmjs.url'</span>, <span class="string">'https://registry.npm.taobao.org'</span>);</span><br><span class="line">    <span class="keyword">const</span> packageUrl = URL.resolve(upLinkUrl, req.originalUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 Verdaccio 定义的 res.report_error 来采集错误</span></span><br><span class="line">    <span class="keyword">const</span> npmRes = request(packageUrl)</span><br><span class="line">      .on(<span class="string">'error'</span>, res.report_error);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接将上游结果转发，快速响应请求</span></span><br><span class="line">    req.pipe(npmRes).pipe(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  route.get(<span class="string">'/:package/:version?'</span>, can(<span class="string">'access'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是 stream 方式的修改，也可以把路由改写为中间件。stream 转发减轻了服务的内存压力（节省上百 MB 的临时缓冲），并减少这部分接口 50% 以上的 TTFB 响应时间，不过总体响应时间却因为 stream 有所延长。</p><p>降低机器负载的目标达成了，但压力测试证明这会大大拖慢进程的处理效率，在并发较低的情况下才能采用。</p><p>作为尝试，目前这个 patch 只用在了特定依赖。Verdaccio 可优化的方向很多，单进程可提升空间有限的情况，该把重心放在横向扩展上了。</p><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>转发所有上游 npm 包的念想还未落地，虽然做起来应该很简单，但需要继续摸索 Verdaccio 结构，才好给出更合适的修改方案。</p><p>现在能给出的最简单做法就是适当调高 Verdaccio 默认 2 分钟的缓存 TTL。提升最大的做法是扩展 Verdaccio 尚未支持的 Cluster 架构……</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request(&#123; <span class="attr">url</span>: packageUrl, <span class="attr">encoding</span>: <span class="literal">null</span> &#125;, (error, resp, body) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> res.report_error(error);</span><br><span class="line">  res.set(<span class="string">'Content-Type'</span>, resp.headers[<span class="string">'content-type'</span>]);</span><br><span class="line">  <span class="keyword">return</span> res.send(body);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再者，结合自身情况，可以尝试更多玩法。如果系统内存富足，把 stream 稍微改一改，变为回调形式。缺点和 Verdaccio 一样的是必须等 resp 完整返回，但 <code>encoding: null</code> 确保响应结果为 buffer，能省略 JSON 解析，优点是可以基于 buffer 做 LRU Cache。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;这里的 &lt;a href=&quot;https://github.com/verdaccio/verdaccio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Verdaccio&lt;/a&gt; 是指用于搭建轻量级 npm 私有仓库的开源解决方案，以下简称 npm 私服。&lt;/p&gt;
&lt;p&gt;近期观察发现，有些项目依赖了名为 &lt;code&gt;npm&lt;/code&gt; 的 npm 包，每次项目部署时都会向私服 &lt;code&gt;/npm&lt;/code&gt; 发起请求记录，并在监控曲线上呈明显的高耗时，这引起了我们的关注。&lt;/p&gt;
&lt;p&gt;有些项目依赖了 npm 自身的包，每次项目部署时都会产生对私服 &lt;code&gt;/npm&lt;/code&gt; 路由的请求记录，并在监控曲线上呈明显的高耗时，这引起了我们的关注。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="npm" scheme="http://claude-ray.com/tags/npm/"/>
    
      <category term="Verdaccio" scheme="http://claude-ray.com/tags/Verdaccio/"/>
    
      <category term="private npm registry" scheme="http://claude-ray.com/tags/private-npm-registry/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP DataLab 题解</title>
    <link href="http://claude-ray.com/2019/10/02/csapp-datalab/"/>
    <id>http://claude-ray.com/2019/10/02/csapp-datalab/</id>
    <published>2019-10-02T15:19:44.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DataLab"><a href="#DataLab" class="headerlink" title="DataLab"></a>DataLab</h1><p>近来开始读 CS:APP3e 第二章，但干看书做课后题太乏味，于是提前把 DataLab 拉出来练练。不一定是优解，趁热记录一下思路吧。</p><a id="more"></a><blockquote><p>如果读者是那种还没做完 lab 就想借鉴答案的，还请收手，坚持独立完成吧，正如课程作者所说，<code>Don&#39;t cheat, even the act of searching is checting.</code></p></blockquote><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的公式可以写作 <code>(x &amp; y) | (~x &amp; y)</code> ，但题目要求只能用 ~ &amp; 两种操作，换句话就是考察用 ~ &amp; 来实现 | 操作，和逻辑与或非类似。</p><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目就是计算出 <code>0x80000000</code> ，基本的移位操作即可，不用复杂化。</p><h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经知道怎么获取 TMIN，TMAX 可以用 ~TMIN 表示，因此主要考察两个数是否相等 —— <code>^</code>。</p><h3 id="错误更正"><a href="#错误更正" class="headerlink" title="错误更正"></a>错误更正</h3><blockquote><p>感谢 <a href="https://github.com/nerrons" target="_blank" rel="noopener">@nerrons</a> 兄指正</p></blockquote><p>前面的解法忽略了操作符的限制，是不合题意的。故更换思路：由于 TMAX + 1 可得到 TMIN，若 x 为 TMAX，则 x + 1 + x 结果为 0。</p><p>但直接这样写无法通过检测程序，是因为 0xffffffff 同样满足 x + 1 + x 为 0 的特性，需要将该情况排除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~((x + <span class="number">1</span>) + x) | !(x + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> odd = (<span class="number">0xAA</span> &lt;&lt; <span class="number">24</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xAA</span>;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; odd) ^ odd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先构造 <code>0xAAAAAAAA</code>，利用 &amp; 操作将所有奇数位提出来，再和已构造的数判等。</p><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制基础扎实的话，可以秒出结果。</p><h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* (x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x) &gt;=0 */</span></span><br><span class="line">  <span class="keyword">int</span> TMIN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !((x + ~<span class="number">0x30</span> + <span class="number">1</span>) &amp; TMIN) &amp; !((<span class="number">0x39</span> + ~x + <span class="number">1</span>) &amp; TMIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要思路可以用逻辑运算表示，<code>(x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x) &gt;=0</code>，这里新概念是如何判断数值是否小于 0。</p><h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = ~(!x) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> of = ~f;</span><br><span class="line">  <span class="keyword">return</span> ((f ^ y) &amp; of) | ((of ^ z) &amp; f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我用 <code>~(!x) + 1</code> 构造了 x 的类布尔表示，如果 x 为真，表达式结果为 0，反之表达式结果为 ~0。</p><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* (y &gt;=0 &amp;&amp; x &lt;0) || ((x * y &gt;= 0) &amp;&amp; (y + (-x) &gt;= 0)) */</span></span><br><span class="line">  <span class="keyword">int</span> signX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> signY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> signXSubY = ((y + ~x + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (signX &amp; ~signY) | (!(signX ^ signY) &amp; !signXSubY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是判断 <code>y + (-x) &gt;= 0</code>。一开始我做题时被 <code>0x80000000</code> 边界条件烦到了，所以将其考虑进了判断条件。</p><p>具体做法是判断 Y 等于 TMIN 时返回 0，X 等于 TMIN 时返回 1。此外也考虑了若 x 为负 y 为 正返回 1，x 为正 y 为负返回 0。</p><p>这样想得太复杂了，使用的操作有点多，而题目对 ops 限制是 24，担心过不了 dlc 的语法检查。 所以又花更多时间想出更简单的方法。用逻辑操作可以写作 <code>(y &gt;=0 &amp;&amp; x &lt;0) || ((x * y &gt;= 0) &amp;&amp; (y + (-x) &gt;= 0))</code>。不过我后来在 linux 上运行了一下第一种方法，dlc 并没有报错。</p><h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> TMAX = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">return</span> (sign ^ <span class="number">1</span>) &amp; ((((x + TMAX) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x 小于 0 时结果为 1，否则检查 <code>x + TMAX</code> 是否进位为负数。</p><h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> f = ~(!sign) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> of = ~f;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * NOTing x to remove the effect of the sign bit.</span></span><br><span class="line"><span class="comment">   * x = x &lt; 0 ? ~x : x</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  x = ((f ^ ~x) &amp; of) | ((of ^ x) &amp; f);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * We need to get the index of the highest bit 1.</span></span><br><span class="line"><span class="comment">   * Easy to find that if it's even-numbered, `n` will lose the length of 1.</span></span><br><span class="line"><span class="comment">   * But the odd-numvered won't.</span></span><br><span class="line"><span class="comment">   * So let's left shift 1 (for the first 1) to fix this.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  x |= (x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Get index with bisection.</span></span><br><span class="line">  n += (!!(x &amp; (~<span class="number">0</span> &lt;&lt; (n + <span class="number">16</span>)))) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  n += (!!(x &amp; (~<span class="number">0</span> &lt;&lt; (n + <span class="number">8</span>)))) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  n += (!!(x &amp; (~<span class="number">0</span> &lt;&lt; (n + <span class="number">4</span>)))) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  n += (!!(x &amp; (~<span class="number">0</span> &lt;&lt; (n + <span class="number">2</span>)))) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  n += !!(x &amp; (~<span class="number">0</span> &lt;&lt; (n + <span class="number">1</span>)));</span><br><span class="line">  <span class="comment">// Add one more for the sign bit.</span></span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我利用了之前 conditional 的做法，讲 x 为负的情况排除掉，统一处理正整数。统计位数可以采取二分法查找最高位的 1，但做了几轮测试就会发现二分法存在漏位的问题。</p><p>不过这只在偶数位发生，奇数位不受影响。因此为了排除这个影响，我暴力地用 <code>x |= (x &lt;&lt; 1)</code> 的办法让最高位的 1 左移 1 位。 </p><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// Special</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>)</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="comment">// Denormalized</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ((uf &amp; <span class="number">0x007fffff</span>) &lt;&lt; <span class="number">1</span>) | (uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">  <span class="comment">// Normalized</span></span><br><span class="line">  <span class="keyword">return</span> uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要简单地取出指数部分，甚至不需要拆解，排除 INF、NaN、非规格化的情况之后，剩下规格化的处理是指数部分的位进一。</p><h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> TMIN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = ((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>) - <span class="number">127</span>;</span><br><span class="line">  <span class="comment">// Out of range</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> TMIN;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>;</span><br><span class="line">  <span class="comment">// Left shift or right shift</span></span><br><span class="line">  <span class="keyword">int</span> f = (<span class="built_in">exp</span> &gt; <span class="number">23</span>) ? (frac &lt;&lt; (<span class="built_in">exp</span> - <span class="number">23</span>)) : (frac &gt;&gt; (<span class="number">23</span> - <span class="built_in">exp</span>));</span><br><span class="line">  <span class="comment">// Sign</span></span><br><span class="line">  <span class="keyword">return</span> (uf &amp; TMIN) ? -f : f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先拆分单精度浮点数的指数和基数，指数部分减去 127 偏移量，用来排除临界条件。大于 31 时，超过 32 位 Two’s Complement 的最大范围，小于 0 则忽略不计，根据题意分别返回 0x80000000 和 0。</p><p>之后根据指数部分是否大于 23 来判断小数点位置。如果大于，说明小数部分全部在小数点左边，需要左移；如果小于则需要右移。最后补上符号位。</p><h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">  <span class="comment">// 0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// INF</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">0xFF</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加 127 得到指数阶码，超过表示范围则返回 0 和 INF。由于小数点后面都是 0，只需左移指数部分。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在 Mac 已无法运行 32 位的代码检查工具 dlc，不过可以先跑逻辑测试，等写完再放到 Linux 机跑一遍 dlc 测试。</p><p>原以为这点知识在学校掌握得还可以，随书习题和前几道 lab 也的确简单，实际做到后面有许多卡壳的点，浮点数的概念都模糊了，真是一边翻书一边做，快两天才完成。书本的这章我还是甭跳了，继续刷去吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DataLab&quot;&gt;&lt;a href=&quot;#DataLab&quot; class=&quot;headerlink&quot; title=&quot;DataLab&quot;&gt;&lt;/a&gt;DataLab&lt;/h1&gt;&lt;p&gt;近来开始读 CS:APP3e 第二章，但干看书做课后题太乏味，于是提前把 DataLab 拉出来练练。不一定是优解，趁热记录一下思路吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer System" scheme="http://claude-ray.com/categories/Computer-System/"/>
    
    
      <category term="DataLab" scheme="http://claude-ray.com/tags/DataLab/"/>
    
      <category term="CSAPP" scheme="http://claude-ray.com/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>不靠谱的 Egg.js 框架开发指南</title>
    <link href="http://claude-ray.com/2019/09/17/egg-framework-dev/"/>
    <id>http://claude-ray.com/2019/09/17/egg-framework-dev/</id>
    <published>2019-09-17T11:44:02.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇面向 Egg.js 上层框架开发者的科普文。</p><p>Egg 官网基本做到了呈现所有“必知必会”的内容，再写一份 Egg 使用教程已经毫无必要，不如聊聊 Egg 上层框架开发过程中可能有用的技巧。</p><a id="more"></a><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>深入浅出的官网和专栏分享</p><ul><li><a href="https://eggjs.org" target="_blank" rel="noopener">eggjs.org</a></li><li><a href="https://www.yuque.com/egg/nodejs" target="_blank" rel="noopener">yuque.com/egg/nodejs</a></li><li><a href="https://zhuanlan.zhihu.com/eggjs" target="_blank" rel="noopener">zhuanlan.zhihu.com/eggjs</a></li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>阅读源码的必经之路</p><ul><li>egg-core</li><li>egg-cluster</li></ul><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><ul><li>egg-scripts: 用于生产环境的部署工具</li><li>egg-bin: 开发环境的 debug、test、coverage</li><li>ets: egg-ts-helper，用于辅助 egg ts 项目生成 .d.ts 声明文件，为 egg 的 ts 开发提供友好的智能提示，已经被 egg-bin 内部集成</li><li>egg-init: egg 的脚手架初始化工具，框架开发者总是需要搭建自己的脚手架，因此这个可以仅作了解，我们并不会使用。自 npm@6 以后，增加了 npm-init 的新特性<ul><li>npm init foo -&gt; npx create-foo</li><li>npm init @usr/foo -&gt; npx @usr/create-foo</li><li>npm init @usr -&gt; npx @usr/create</li></ul></li></ul><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><ul><li>egg-mock: 提供了完整的 mock 代码，测试 API 来自 supertest</li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>进阶 Egg 的步骤包括但不限于通读官网文档，至少要熟悉下面两个话题才能算了解了 Egg。</p><ul><li><p><a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html" target="_blank" rel="noopener">多进程模型</a></p></li><li><p><a href="https://eggjs.org/zh-cn/advanced/loader.html" target="_blank" rel="noopener">loader &amp;&amp; 生命周期</a></p></li></ul><h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><p>接下来是几个或多或少官网没有讲到的话题。</p><h2 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a>平滑重启</h2><p>Egg 的多进程模型决定了 PM2 这样的进程管理工具对它意义不大。可惜的是没有了 PM2，我们也失去了 pm2 reload 这样轻量的平滑重启方案，鉴于 Egg 应用不短的启动时长，必须在流量进入 Node.js 之前加以控制。</p><p>对有强力运维的团队来讲，server 的启动时间不是问题，问题是还有不少 Node.js 项目只有一层代理甚至是裸运行的，又不想给运维加钱。对此最基本的建议是前置 nginx ，在配置多个节点的 upstream 之后，默认的选服策略就带上了容错机制。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com       weight=<span class="number">5</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">60s</span>;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com:<span class="number">8080</span>  weight=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">8080</span>   backup;</span><br><span class="line">    <span class="attribute">server</span> backup2.example.com:<span class="number">8080</span>   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，fail_timeout 默认 (10s) 就可以提供一个 “server backend 被 nginx 判定不可用之后，10s 之内不会有新的请求发送到该地址” 的缓冲期。</p><p>参考 nginx 的配置说明，酌情调整 <code>max_fails</code>、<code>fail_timeout</code> 等参数，为服务提供一个基本但可靠的稳定保障吧。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="egg-router-vs-koa-router"><a href="#egg-router-vs-koa-router" class="headerlink" title="egg-router vs koa-router"></a>egg-router vs koa-router</h3><p>egg-router 的逻辑基于 koa-router，早期直接引用 koa-router，在其基础上封装了 Egg.js 应用的路由注册，以及其他小特性。 后来 egg-router 从 egg-core 中剥离，并更改维护方式为 fork（koa-router 的维护度太低了），但没有做 breaking changes。两者的主要差别如下，稍后会做详细介绍：</p><ul><li>RESTful</li><li>默认大小写敏感</li></ul><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>koa-router 提供了比较基础的 RESTful API 支持，<code>.get|put|post|patch|delete|del</code>。</p><p>Egg 实现了一套应用较广的约定，以便在 Egg 应用中快速编写 RESTful CRUD。</p><p><code>app.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller)</code></p><table><thead><tr><th>Method</th><th>Path</th><th>Route Name</th><th>Controller.Action</th></tr></thead><tbody><tr><td>GET</td><td>/posts</td><td>posts</td><td>app.controllers.posts.index</td></tr><tr><td>GET</td><td>/posts/new</td><td>new_post</td><td>app.controllers.posts.new</td></tr><tr><td>GET</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.show</td></tr><tr><td>GET</td><td>/posts/:id/edit</td><td>edit_post</td><td>app.controllers.posts.edit</td></tr><tr><td>POST</td><td>/posts</td><td>posts</td><td>app.controllers.posts.create</td></tr><tr><td>PUT</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.update</td></tr><tr><td>DELETE</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.destroy</td></tr></tbody></table><p>举例如下，根据以上映射关系，在 <code>app/controller/post.js</code> 中选择性地实现相应方法即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.resources(<span class="string">'/posts'</span>, <span class="string">'posts'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>route name 是 koa-router 就定义了的可选参数，如果指定了 route name，当路由匹配成功时，会将此 name 赋值给 ctx._matchedRouteName</p></blockquote><h3 id="sensitive"><a href="#sensitive" class="headerlink" title="sensitive"></a>sensitive</h3><p>Egg 在创建 router 的时候传递了 sensitive=true 的选型，在 koa-router 中开启了大小写敏感。<br> <a href="https://github.com/eggjs/egg-core/blob/master/lib/egg.js#L301" target="_blank" rel="noopener">sensitive=true</a></p><h3 id="Radix-Tree"><a href="#Radix-Tree" class="headerlink" title="Radix Tree"></a>Radix Tree</h3><p>Radix Tree 是一种基于前缀的查找算法，Golang 的 echo、gin 等 web 框架的路由匹配都使用了该算法。</p><p>而 egg-router(koa-router) 以及 express router 均采用传统的正则匹配，具体做法是用 path-to-regexp 将路由转化为正则表达式，路由寻址就是遍历查找符合当前路径的路由的过程。</p><p>对比基于两种算法的路由查找效率，Radix Tree 更占优势，并且 url 越长，路由数量越多，性能差距越大。</p><p>以下是 10000 个路由情况下主流路由中间件的性能比拼，数据截选自 <code>koa-rapid-router</code> 。</p><p>静态路由</p><table><thead><tr><th>Architecture</th><th>Latency</th><th>Req/Sec</th><th>Bytes/Sec</th></tr></thead><tbody><tr><td><code>koa + koa-router</code></td><td>245.07 ms</td><td>394.25</td><td>56 kB</td></tr><tr><td><code>fastify</code></td><td>1.96 ms</td><td>49324</td><td><strong>7 MB</strong></td></tr></tbody></table><p>动态路由</p><table><thead><tr><th>Architecture</th><th>Latency</th><th>Req/Sec</th><th>Bytes/Sec</th></tr></thead><tbody><tr><td><code>koa + koa-router</code></td><td>220.29 ms</td><td>441.75</td><td>62.7 kB</td></tr><tr><td><code>fastify</code></td><td>1.9 ms</td><td>50988.65</td><td><strong>7.24 MB</strong></td></tr></tbody></table><p>那为什么不全面使用 Radix Tree 呢？其实只有少数涉及大量路由和性能的场景，如 npm registery。</p><p>如果项目真的有如此性能需要，恐怕你不得不考虑用该算法编写的路由中间件来取代默认的 egg-router 了。</p><h2 id="引入-Elastic-APM"><a href="#引入-Elastic-APM" class="headerlink" title="引入 Elastic APM"></a>引入 Elastic APM</h2><h3 id="如何支持-egg-框架"><a href="#如何支持-egg-框架" class="headerlink" title="如何支持 egg 框架"></a>如何支持 egg 框架</h3><p>需求：elastic-apm hook 必须在 Egg 和 egg-router 被 require 前完成加载。</p><p>之前有一篇更详细的文章《<a href="http://claude-ray.com/2019/07/12/elastic-apm-node-egg/">elastic-apm-node 扩展篇 —— Egg</a>》，适用于 Egg 应用层的 APM 接入。而在框架层则简单许多，可以直接在框架入口文件做此处理，应用开发者无须再关心这个包的处理细节。</p><h3 id="ts-项目启动卡住"><a href="#ts-项目启动卡住" class="headerlink" title="ts 项目启动卡住"></a>ts 项目启动卡住</h3><p>由于 egg-bin 内置的 ets (egg-ts-helper) 会用子进程同步地预加载一部分 ts 代码用作检查，apm 会被顺势加载，如果配置的环境变量或 serverUrl 字段有误，导致访问无法连通的 apm-server，最终会让该子进程挂起，ets 无法正常退出。</p><blockquote><p>ets 只在 <code>egg-bin start/dev/debug</code> 启动 ts 项目时生效，不会影响线上经过编译的 js <code>egg-script start</code> 启动。</p></blockquote><p>针对上述情况，增加了默认不在 ets 编译过程启动的处理，特征是存在 <code>ETS_REGISTER_PID</code> 环境变量。因此实际上运行调试和测试时都不会开启 apm。</p><p>同时单独运行 <code>ets</code> 时没有上述变量，因此将 NODE_ENV 为 undefined 的环境也排除。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enableAPM = process.env.APM_ENABLE || (!process.env.ETS_REGISTER_PID &amp;&amp; process.env.NODE_ENV);</span><br><span class="line"><span class="keyword">if</span> (enableAPM) &#123;</span><br><span class="line">  <span class="keyword">const</span> isDev = process.env.APM_DEV === <span class="string">'true'</span> || process.env.NODE_ENV !== <span class="string">'production'</span>;</span><br><span class="line">  apm.start(&#123; isDev &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架仓库管理"><a href="#框架仓库管理" class="headerlink" title="框架仓库管理"></a>框架仓库管理</h2><p>在 npm 官方提供 momorepo 的正式支持之前，我们可以使用 Lerna 作为统一的框架、插件管理工具。</p><p>对于我们日常需要的 npm 管理操作，Lerna 并没有引入太多额外的使用成本，并且可以通过 npm 指令一一封装。</p><p>使用方式其实非常灵活，按团队的习惯来就好。如果之前没有使用过，可以参考 midway/scripts 下的 Lerna <a href="https://github.com/midwayjs/midway/blob/master/scripts" target="_blank" rel="noopener">脚本</a>，并且可以在 CI 构建过程中执行版本更迭和发布。</p><h2 id="获取实时-ctx"><a href="#获取实时-ctx" class="headerlink" title="获取实时 ctx"></a>获取实时 ctx</h2><p>框架开发时遇到了一个少见情况，需要通过 Egg 的 app 对象获取当前上下文的 ctx 对象，用于在特别插件的中间件函数中定位 Egg 的上下文，以实现插件日志挂载到 ctx 对象。</p><blockquote><p>其实这是一个没什么用的需求 :)</p></blockquote><p>听起来比较绕，举个例子，在 egg 中使用 dubbo2.js —— 引入的方式参考 dubbo2.js 和 egg 的集成指引文档，并在其中使用中间件扩展</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;plugin_root&#125; ./app.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dubbo = Dubbo.from(&#123;....&#125;);</span><br><span class="line">  app.beforeStart(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    dubbo.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">      <span class="keyword">const</span> endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'costtime: %d'</span>, endTime - startTime);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> dubbo.ready();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dubbo was ready...'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的 ctx 并不属于 egg 创建的 ctx，两者之间相互隔离。唯一能让两者产生联系的，就是使用闭包中的 app。</p><p>于是有了 <code>egg-current-ctx</code> 这个模块，借助 app.currentCtx 方法，可以将两种 ctx 联系起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dubbo = Dubbo.from(&#123;....&#125;);</span><br><span class="line">  app.beforeStart(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    dubbo.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">const</span> eggCtx = app.currentCtx;</span><br><span class="line">      <span class="comment">// 对 eggCtx 处理</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">''</span>, eggCtx.query);</span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">      <span class="keyword">const</span> endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'costtime: %d'</span>, endTime - startTime);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> dubbo.ready();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dubbo was ready...'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想把 dubbo2.js 中 ctx 的属性挂载到 egg 的 ctx 上，这个没什么卵用的插件就能散发一点温度。</p><p>感兴趣的可以看 egg-current-ctx 的<a href="https://github.com/Claude-Ray/egg-current-ctx" target="_blank" rel="noopener">代码实现</a>，基于 async_hooks。</p><h2 id="发布加速"><a href="#发布加速" class="headerlink" title="发布加速"></a>发布加速</h2><p>Egg + ts 应用具备 150M 起步的 node_modules，再加上网络原因（和小水管 npm 私服），安装、拷贝速度十分感人。</p><p>如何提速？</p><blockquote><p>这里旨在提供解决思路，一定有更好的方案，欢迎交流指正</p></blockquote><ol><li><p>node_modules 不再每次都安装，打包平台和线上环境缓存第一次安装的依赖。(参考 travis-ci)</p></li><li><p>针对前一点的改进，node_modules 安装在代码目录上层，发布平台只拷贝代码，版本号式迭代。</p><p> 可是目录层级的处理在 Egg 项目上略显吃力，需要一套完整的项目和测试用例协助试错。因为 egg-utils 等工具类的底层代码将 node_modules 目录层级写得太死了。</p><p> 举个例子，<code>egg-utils/lib/framework.js 66L</code> ，导致无法查找上层 node_modules 里的 egg 依赖</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertAndReturn</span>(<span class="params">frameworkName, moduleDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> moduleDirs = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">    moduleDir,</span><br><span class="line">    <span class="comment">// find framework from process.cwd, especially for test,</span></span><br><span class="line">    <span class="comment">// the application is in test/fixtures/app,</span></span><br><span class="line">    <span class="comment">// and framework is install in $&#123;cwd&#125;/node_modules</span></span><br><span class="line">    path.join(process.cwd(), <span class="string">'node_modules'</span>),</span><br><span class="line">    <span class="comment">// prevent from mocking process.cwd</span></span><br><span class="line">    path.join(initCwd, <span class="string">'node_modules'</span>),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> moduleDir <span class="keyword">of</span> moduleDirs) &#123;</span><br><span class="line">    <span class="keyword">const</span> frameworkPath = path.join(moduleDir, frameworkName);</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(frameworkPath)) <span class="keyword">return</span> frameworkPath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;frameworkName&#125;</span> is not found in <span class="subst">$&#123;<span class="built_in">Array</span>.<span class="keyword">from</span>(moduleDirs)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>npm 私服优化。修改上游镜像是一方面，自建的服务如果无法支持多节点多进程，也很容易成为安装依赖的性能瓶颈。假如使用 verdaccio 的本地存储模式，将很难得到官方 cluster 方案支持，除非你购买了 google cloud 或 aws s3。</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/chenshenhai/eggjs-note" target="_blank" rel="noopener">chenshenhai/eggjs-note</a></li><li><a href="https://github.com/cevio/koa-rapid-router" target="_blank" rel="noopener">koa-rapid-router</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇面向 Egg.js 上层框架开发者的科普文。&lt;/p&gt;
&lt;p&gt;Egg 官网基本做到了呈现所有“必知必会”的内容，再写一份 Egg 使用教程已经毫无必要，不如聊聊 Egg 上层框架开发过程中可能有用的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
      <category term="Egg" scheme="http://claude-ray.com/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>如何解决 Debian 系 Elastic apm-server 7.x 启动失败</title>
    <link href="http://claude-ray.com/2019/09/13/apm-server-startup-troubleshooting/"/>
    <id>http://claude-ray.com/2019/09/13/apm-server-startup-troubleshooting/</id>
    <published>2019-09-13T03:55:57.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>本来是几个月前在 Ubuntu 部署 Elastic apm-server 遇到的问题，当时处理起来没遇到特别的卡点，就只是把解决过程丢到 Evernote 了。最近发现还有人在重复踩这个坑，因此我把笔记整理之后搬到这里作一个极简的分享。</p><a id="more"></a><h1 id="apm-server-安装"><a href="#apm-server-安装" class="headerlink" title="apm-server 安装"></a>apm-server 安装</h1><p>实际步骤就不需要我复述了，官方提供现成的 deb 安装包。除了查看官方文档，更推荐使用 Kibana APM 看板自带的指南。</p><p>指南的 url 路径大概是 <a href="http://localhost:5601/app/kibana#/home/tutorial/apm?_g=()" target="_blank" rel="noopener">http://localhost:5601/app/kibana#/home/tutorial/apm?_g=()</a></p><p>不仅有安装引导，还提供按钮协助检查 apm-server 的服务状态。</p><p><img src="/image/apm-server-startup-troubleshooting/kibana-apm-server-tutorial.png" alt="Kibana apm-server tutorial"></p><h1 id="启动异常"><a href="#启动异常" class="headerlink" title="启动异常"></a>启动异常</h1><p>在 debian 系发行版安装 apm-server 后，执行 <code>service apm-server start</code> 报告失败，且切换到 <code>systemctl</code> 也无效。</p><p><code>service apm-server status</code>报错如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ service apm-server status                                                                                          </span><br><span class="line">● apm-server.service - Elastic APM Server                                                                               </span><br><span class="line">   Loaded: loaded (/lib/systemd/system/apm-server.service; enabled; vendor preset: enabled)                             </span><br><span class="line">   Active: failed (Result: <span class="built_in">exit</span>-code) since Tue 2019-04-16 14:44:42 CST; 3s ago                                         </span><br><span class="line">     Docs: https://www.elastic.co/solutions/apm                                                                         </span><br><span class="line">  Process: 4783 ExecStart=/usr/share/apm-server/bin/apm-server <span class="variable">$BEAT_LOG_OPTS</span> <span class="variable">$BEAT_CONFIG_OPTS</span> <span class="variable">$BEAT_PATH_OPTS</span> (code=ex</span><br><span class="line"> Main PID: 4783 (code=exited, status=1/FAILURE)                                                                         </span><br><span class="line">                                                                                                                        </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Service hold-off time over, scheduling restart.                     </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Scheduled restart job, restart counter is at 5.                     </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: Stopped Elastic APM Server.                                                             </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Start request repeated too quickly.                                 </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Failed with result <span class="string">'exit-code'</span>.                                     </span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: Failed to start Elastic APM Server.</span><br></pre></td></tr></table></figure><h1 id="检查日志"><a href="#检查日志" class="headerlink" title="检查日志"></a>检查日志</h1><p>首先使用 <code>journalctl</code> 查看 systemd 的日志，如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u apm-server.service</span><br></pre></td></tr></table></figure><p>打印日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- Logs begin at Wed 2019-04-10 09:30:25 CST, end at Tue 2019-04-16 14:44:42 CST. --                                    </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: Started Elastic APM Server.                                                             </span><br><span class="line">4 月 16 13:43:23 ray apm-server[2487]: Exiting: error loading config file: config file (<span class="string">"/etc/apm-server/apm-server.yml"</span>)</span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: apm-server.service: Main process exited, code=exited, status=1/FAILURE                  </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: apm-server.service: Failed with result <span class="string">'exit-code'</span>.                                     </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: apm-server.service: Service hold-off time over, scheduling restart.                     </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: apm-server.service: Scheduled restart job, restart counter is at 1.                     </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: Stopped Elastic APM Server.                                                             </span><br><span class="line">4 月 16 13:43:23 ray systemd[1]: Started Elastic APM Server.</span><br><span class="line"><span class="comment"># ... ，笔者注释，省略中间的多次重启信息</span></span><br><span class="line">4 月 16 14:44:42 ray apm-server[4783]: Exiting: error loading config file: config file (<span class="string">"/etc/apm-server/apm-server.yml"</span>)</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Main process exited, code=exited, status=1/FAILURE</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Failed with result <span class="string">'exit-code'</span>.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Service hold-off time over, scheduling restart.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Scheduled restart job, restart counter is at 5.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: Stopped Elastic APM Server.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Start request repeated too quickly.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: apm-server.service: Failed with result <span class="string">'exit-code'</span>.</span><br><span class="line">4 月 16 14:44:42 ray systemd[1]: Failed to start Elastic APM Server.</span><br></pre></td></tr></table></figure><p>这样找出真正的启动错误是 <code>Exiting: error loading config file: config file (&quot;/etc/apm-server/apm-server.yml&quot;)</code></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>配置文件异常，采用 <code>apm-server export config</code> 进一步观察。提示如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error initializing beat: error loading config file: config file (<span class="string">"/etc/apm-server/apm-server.yml"</span>) must be owned by the beat user (uid=1000) or root</span><br></pre></td></tr></table></figure><p><a href="https://github.com/elastic/apm-server/issues/2001" target="_blank" rel="noopener">github issues</a> 上找到了类似的问题，但没有给出推荐的处理方案，所以决定自己动手解决。</p><p><code>ls -l</code> 观察 <code>/etc/apm-server/</code> 的信息，发现除了 apm-server.yml 之外，owner 都是 root</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc/apm-server</span><br><span class="line">total 148K</span><br><span class="line">drwxr-xr-x   2 root       root       4.0K 4 月  16 14:11 .</span><br><span class="line">drwxr-xr-x 142 root       root        12K 4 月  16 14:11 ..</span><br><span class="line">-rw-------   1 apm-server apm-server  33K 4 月   6 05:48 apm-server.yml</span><br><span class="line">-rw-r--r--   1 root       root        94K 4 月   6 05:48 fields.yml</span><br></pre></td></tr></table></figure><p>那么统一将权限变更到 root 吧！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root:root /etc/apm-server/apm-server.yml</span><br></pre></td></tr></table></figure><p>改之后测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apm-server <span class="built_in">test</span> config</span><br><span class="line">Config OK</span><br></pre></td></tr></table></figure><p>再尝试启动则提示成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是几个月前在 Ubuntu 部署 Elastic apm-server 遇到的问题，当时处理起来没遇到特别的卡点，就只是把解决过程丢到 Evernote 了。最近发现还有人在重复踩这个坑，因此我把笔记整理之后搬到这里作一个极简的分享。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://claude-ray.com/categories/Linux/"/>
    
    
      <category term="APM" scheme="http://claude-ray.com/tags/APM/"/>
    
      <category term="Elastic-APM" scheme="http://claude-ray.com/tags/Elastic-APM/"/>
    
      <category term="apm-server" scheme="http://claude-ray.com/tags/apm-server/"/>
    
      <category term="Debian" scheme="http://claude-ray.com/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT 主题升级 7.4</title>
    <link href="http://claude-ray.com/2019/09/12/hexo-theme-next-upgrade-7-4/"/>
    <id>http://claude-ray.com/2019/09/12/hexo-theme-next-upgrade-7-4/</id>
    <published>2019-09-12T12:06:19.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>使用 7.1.2 才过了不到 3 个月，我又将博客主题升级了，不过这次是因为 sidebar 出现了统计隐藏的样式 bug，没想到意外赶上了几个特别明显的优化。这次是真的值得所有 NexT 老用户去尝试了。</p><a id="more"></a><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>从我的体验来看，生成页面的耗时直接减半，对比 5 -&gt; 7.1.2 版本升级的提速，效果相当可观。</p><h2 id="定制代码注入"><a href="#定制代码注入" class="headerlink" title="定制代码注入"></a>定制代码注入</h2><p>这个是绝对好评了！目前最常见的维护主题代码的方式就是人工 clone theme-next 到 <code>themes/next</code> 目录，除非 fork 一份仓库自己维护，所有定制的内容必须在 <code>themes/next</code> 目录修改，版本管理混在一起，一旦想升级主题，得挨个检查被自己修改过的文件。</p><p>现在可以将定制代码和原 NexT 主题代码完全隔离，自己添加的修改全都提取到 hexo 站点的 <code>source/_data</code> 目录下。只需要保管好 <code>_config.yml</code>，以后的主题更新方式就轻松地变为一键拉取最新代码。</p><p>注意需要配置开启对应的 <code>custom_file_path</code>，支持的模块如下，几乎全面满足定制需要。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># 页面</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment"># 样式</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>可以参考我迁移后的扩展代码：<a href="https://github.com/Claude-Ray/claude-ray.github.io/tree/hexo/source/_data" target="_blank" rel="noopener">https://github.com/Claude-Ray/claude-ray.github.io/tree/hexo/source/_data</a></p><h2 id="使用-em-取代-px"><a href="#使用-em-取代-px" class="headerlink" title="使用 em 取代 px"></a>使用 em 取代 px</h2><p>扩大了自适应的范围，但我实在接受不了它在高分屏下的超大字体，没关系，上面提供的<code>source/_data/variables.styl</code> 可以用来重写 base.styl 中的变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Font size</span></span><br><span class="line">$font-size-large          = 1em;</span><br><span class="line">$font-size-larger         = 1.125em;</span><br><span class="line">$font-size-largest        = 1.25em;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Headings font size</span></span><br><span class="line">$font-size-headings-base  = 1.6em;</span><br></pre></td></tr></table></figure><p>以上配置差不多就可以恢复原来的视觉效果了。</p><h2 id="配置结构优化"><a href="#配置结构优化" class="headerlink" title="配置结构优化"></a>配置结构优化</h2><p>关于 <code>sidebar</code> 位置的配置终于可以在所有主题中统一生效了，还有一些其他的简化，迁移配置的时候务必注意对照着修改。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了以上明显的特性更新，还有一堆 bug 修复、渲染优化等等，没毛病！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次的更新不用等了，尤其前两个优化解决了长久以来的痛点，值得升级。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://claude-ray.com/2019/06/28/hexo-theme-next-upgrade-7/">Hexo NexT 主题升级 7.1.2</a></li><li><a href="https://theme-next.org/" target="_blank" rel="noopener">theme-next.org</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 7.1.2 才过了不到 3 个月，我又将博客主题升级了，不过这次是因为 sidebar 出现了统计隐藏的样式 bug，没想到意外赶上了几个特别明显的优化。这次是真的值得所有 NexT 老用户去尝试了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://claude-ray.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://claude-ray.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>From Journeyman to Master</title>
    <link href="http://claude-ray.com/2019/09/10/from-journeyman-to-master/"/>
    <id>http://claude-ray.com/2019/09/10/from-journeyman-to-master/</id>
    <published>2019-09-10T15:45:17.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>《 The Pragmatic Programmer: From Journeyman to Master 》这本书已加入愿望单许久，最近终于在通勤路上读完了。对于处于或将处于熟练工阶段的程序员，毫无疑问这是本值得用心阅读的书，因此我也写一下短评和推荐理由。</p><a id="more"></a><p>作为思想指导性读物，首先它具备不挑剔阅读设备的优点，电子书随处可见的内链（实体书则是页码）可以方便地跳到引用的章节，也能帮读者构建知识的关联体系，因此你可以放心挑选你感兴趣的专题。</p><p>其次，它比《 Code Complete 》更凝练，比《 Unix 编程艺术》更平和。尤其推荐给所有所谓的中级程序员，这一点也体现在了书的副标题上 —— 面向读者为 <code>journeyman</code>，也就是训练有素的熟手。</p><p>虽然中文版将其译为“小工”，私以为也得是足够可靠的小工，更像是许多大牛自谦的说辞，而不代表毫无软件工程基础的 <code>newbie</code>。对于真正的新人而言，阅读此类书籍所遭受的影响可能是深远的，却也可能不及耳旁风。因为随着当代软件工程的普及程度，阅读时多半会觉得这些道理显而易见、理所当然，“几乎都是课堂和应试中学过的”，这种感觉在《 Code Complete 》更甚。建议没有多少工作经验的人，先去读《 Clean Code 》和 《 Refactor 》，实践更为重要，至于编程思考类的读物凭兴趣看一本足以。</p><p>上面是说对未出师的准程序员意义相对较小，而下山历练之人，亲历过绝望的 deadline、妥协的设计以及巨大的屎山，不论将它们克服还是被击败，都更能体会到为何如此常识便是属于大师的技巧与原则。在阅读过程中，就像面向一面镜子自我矫正，你可以不断反思近段时间的行为、状态是否得当。</p><p>接下来分享几个阅读本书的 tips：</p><ul><li>类似《人月神话》，本书用到了大量的比喻，只凭目录的小标题无法直观地理解作者想表达的主旨。放在最后的附录《Quick Reference Guide》原本是用作复习的，但其实它非常值得在正文前初步阅读，作为章节目录的补充，非常契合跳越式阅读的需要。</li><li>英文原版更利于理解作者的思想，透过标题也得承认这一点。</li><li>由于个人记笔记经常疏于回顾，为了提高转化效率，就得强迫自己复习思考。我把《Quick Reference Guide》默背着一字一句地敲了下来，效率不算高，但终究是极短时间内让自己多了一些复习过程，所有不清晰的点也在这一步排除掉了。作为一种输出形式，时间性价比极高。</li></ul><p>然后聊聊对个人印象最深的几个点，虽然不擅长写读后感，但假设有人翻到了这篇博客，希望可以抛砖引玉。</p><ul><li>没有完美的软件，不要任何时候都奉行完美主义，尤其要知道什么时候该停下来。这个对我而言是最为欠缺的，吹毛求疵耗费了大量时间和精力，但从自身角度很难评估哪些时候哪种做法是正确的，正所谓当局者迷。我能想到的对策，除了自省，还必须要走出自己的小圈子，多吸取他人经验。</li><li>不要容忍低劣的设计，留着祸患无穷，盘它，一次不行多来几次，不需要犹豫。我经常认为是自己没有考量好才没有动手，回想起来其实就是犹豫，错失了很多磨练的机会。计算常有遗漏，而踩坑则不然，真动起手来才能弄明白设计者的初衷。只有你不希望为这个软件续命时才可以忽视它……（大误</li><li>提供解决方案，而不是借口。就算心底没想着找借口抵赖，表达方式上也要额外注意，为了提供更有价值的信息，最后解释甚至不解释。这一点可能我做的还好，<del>甩锅是不存在的</del>，而且非常抵触三句之内讲不到重点的沟通。</li></ul><p>原本还想贴一下读书笔记，不然篇幅太短，认真考虑了一下决定不发了，毕竟博客只想放个人产出的东西，书中自有黄金屋，未经加工的笔记还是偷摸着恶心自己吧。</p><p>最后是想对自己说的话。</p><p>事实上我还远未达到熟练工的程度，遇到没挑战的事只能代表未跳出舒适区。矫正可以帮助自己找到舒适区，而破除壁障，需要在技术根本上出力。最近手痒又折腾起周边工具，看一些效率宝典（包括开篇这本书），想寻求新的突破，久而久之其实也是一种逃避。是时候直面最大的舒适区，把焦点回到编码上，突破更多的自我设限，Keep your mind sharp！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《 The Pragmatic Programmer: From Journeyman to Master 》这本书已加入愿望单许久，最近终于在通勤路上读完了。对于处于或将处于熟练工阶段的程序员，毫无疑问这是本值得用心阅读的书，因此我也写一下短评和推荐理由。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="http://claude-ray.com/categories/Essay/"/>
    
    
      <category term="Books" scheme="http://claude-ray.com/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>Mac 上移除 EasyConnect 常驻后台进程</title>
    <link href="http://claude-ray.com/2019/08/24/remove-easyconnect-daemons-on-mac/"/>
    <id>http://claude-ray.com/2019/08/24/remove-easyconnect-daemons-on-mac/</id>
    <published>2019-08-23T17:20:41.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>想必大家已经知道，EasyConnect 会在后台强行添加名为 EasyMonitor 的开机自启守护进程，网上已经有关闭教程了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</span><br></pre></td></tr></table></figure><p>可实际上 EasyConnect 还启动了另一个“杀不掉”的后台进程 ECAgent，活动频率很低，似乎不会造成内存泄漏，略显不起眼。但这无法作为它肆意常驻的理由。</p><a id="more"></a><h1 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h1><p>首先找到 plist 文件，在 <code>/Library/LaunchAgents/com.sangfor.ECAgentProxy.plist</code>。它无法被 launchctl unload，不过没关系，你可以直接把它挪走或删除，并且今后都不再需要它。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist ~</span><br></pre></td></tr></table></figure><p>当然这时候它还是不能被 kill 掉，要想从 launchctl 中删除而不重启电脑，可以采用 launchctl remove。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl remove com.sangfor.ECAgentProxy</span><br></pre></td></tr></table></figure><h1 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h1><p>关闭后台进程之后，启动 EasyConnect 会弹出警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alert</span><br><span class="line"></span><br><span class="line">Initialization failed. Please try reinstalling!</span><br></pre></td></tr></table></figure><p>没办法，只能向恶势力低头，需要使用时，必须重新加载 EasyMonitor。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EasyConnect v7.6.7 开始 EasyMonitor 必须在 root 权限下运行，此前版本可以不加 sudo</span></span><br><span class="line">sudo launchctl load /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</span><br></pre></td></tr></table></figure><p>而 ECAgent 就没这么麻烦了，它根本不必后台常驻 —— EasyConnect 启动时会自己创建一个，并且会随着 EasyConnect 进程一起退出。最终我删掉了 <code>com.sangfor.ECAgentProxy.plist</code> 文件的备份。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://blog.jiayx.net/archives/274.html" target="_blank" rel="noopener">Mac 下禁用开机自启软件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想必大家已经知道，EasyConnect 会在后台强行添加名为 EasyMonitor 的开机自启守护进程，网上已经有关闭教程了&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo launchctl unload /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可实际上 EasyConnect 还启动了另一个“杀不掉”的后台进程 ECAgent，活动频率很低，似乎不会造成内存泄漏，略显不起眼。但这无法作为它肆意常驻的理由。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://claude-ray.com/categories/Mac/"/>
    
    
      <category term="EasyConnect" scheme="http://claude-ray.com/tags/EasyConnect/"/>
    
      <category term="EasyMonitor" scheme="http://claude-ray.com/tags/EasyMonitor/"/>
    
      <category term="ECAgent" scheme="http://claude-ray.com/tags/ECAgent/"/>
    
  </entry>
  
  <entry>
    <title>Nginx SWRR 算法解读</title>
    <link href="http://claude-ray.com/2019/08/10/nginx-swrr/"/>
    <id>http://claude-ray.com/2019/08/10/nginx-swrr/</id>
    <published>2019-08-10T05:13:49.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>Smooth Weighted Round-Robin (SWRR) 是 nginx 默认的加权负载均衡算法，它的重要特点是平滑，避免低权重的节点长时间处于空闲状态，因此被称为平滑加权轮询。</p><blockquote><p>该算法来自 nginx 的一次 commit：<a href="https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1" target="_blank" rel="noopener">Upstream: smooth weighted round-robin balancing</a></p></blockquote><p>在阅读之前，你应该已经了解过 nginx 的几种负载均衡算法，并阅读了 SWRR 的实现。</p><p>介绍此算法的文章有很多，但用数学角度给出证明过程的较少，尽管并不复杂。这里把自己的思路分享一下，为了便于理解，只考虑算法核心的 current_weight，忽略受异常波动影响的 effective_weight。</p><a id="more"></a><h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>在写下博客之前，我还没有翻到其他靠谱的证明过程，就草草记录了自己粗鄙的思路。可发布文章一年之后，再来回顾的我不禁汗颜，为了照顾读者（更未来的自己），参考 <a href="https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/" target="_blank" rel="noopener">nginx平滑的基于权重轮询算法分析</a> 重新梳理了文章脉络。</p><p>以至于现在的内容更像是他人博客的学习笔记，和初版大不相同。这让患有原创洁癖的我深感羞愧，之后的自己务必用更数学的风格去做解析。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>由于所有节点都有原始权重和当前权重，为了方便区分，我们称当前权重为“状态”。</p><p>节点的初始状态均为 0，每开始一轮新的选择，先为各个节点加上其原始权重大小的值，然后选出权重最大的节点，将其值减去所有节点的权重和，最后，该节点作为命中节点返回。</p><p>接下来是官方的示例，对于权重占比 { 5, 1, 1 } 的 A, B, C 三个节点，每轮节点的选择和状态的变换如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">| Round |  A |  B |  C | Selected Node |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|       |  0 |  0 |  0 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     1 |  5 |  1 |  1 | A             |</span><br><span class="line">|       | -2 |  1 |  1 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     2 |  3 |  2 |  2 | A             |</span><br><span class="line">|       | -4 |  2 |  2 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     3 |  1 |  3 |  3 | B             |</span><br><span class="line">|       |  1 | -4 |  3 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     4 |  6 | -3 |  4 | A             |</span><br><span class="line">|       | -1 | -3 |  4 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     5 |  4 | -2 |  5 | C             |</span><br><span class="line">|       |  4 | -2 | -2 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     6 |  9 | -1 | -1 | A             |</span><br><span class="line">|       |  2 | -1 | -1 |               |</span><br><span class="line">|-------|----|----|----|---------------|</span><br><span class="line">|     7 |  7 |  0 |  0 | A             |</span><br><span class="line">|       |  0 |  0 |  0 |               |</span><br></pre></td></tr></table></figure><h2 id="证明思路"><a href="#证明思路" class="headerlink" title="证明思路"></a>证明思路</h2><p>假设有三个服务器节点 A B C，它们的权重分别为 a、b、c 并保持不变，W 表示所有服务器节点权重的总和，即 W = a + b + c。</p><p>根据 SWRR 算法，每台服务器的初始权重均为 0。</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>也可以用等式表达当前的权重（状态）之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum &#x3D; 0 + 0 + 0 &#x3D; 0</span><br></pre></td></tr></table></figure><p>每次开始选择，各节点的状态会增加对应权重的大小。从中选择 CW 最大的节点，并将其值减去 W。</p><p>首先，所有节点加权，不妨设 A 为权重最大的节点，经过第一轮变换之后</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a - W</td><td>b</td><td>c</td></tr></tbody></table><p>此时，节点的状态和仍然为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sum &#x3D; (a - W) + b + c</span><br><span class="line">    &#x3D; (a - a - b - c) + b + c</span><br><span class="line">    &#x3D; 0</span><br></pre></td></tr></table></figure><p>综上，每一轮选择都是将总资源根据权重分配给各自节，再由权重最大的节点一次性消耗掉。依此类推，无论第几次选择，他们的和恒等于零。</p><hr><p>假设 A 已经被选择了 a 轮 (a &lt; W)，即将开始第 n 轮选择（a &lt; n &lt; W），那么 A 节点的状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * a - a * W &#x3D; a * (n - W) &lt; 0</span><br></pre></td></tr></table></figure><p>由于状态总和恒为 0，而 A 节点状态小于 0 的时候一定不会被选中，因此 A 最多只能被选择 a 轮。同理，其他每个节点也最多只能被选择等同于节点权重的次数。</p><hr><p>最后证明算法的平滑性，即 A 节点不会连续被选择 a 次。</p><p>不妨设 A 节点已经被连续选择了 a - 1 次，那么当前 A 节点的状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a - 1) * a - (a - 1) * W &#x3D; (a - 1) * (a - W) &lt; 0</span><br></pre></td></tr></table></figure><p>同上一条证明，由于状态总和恒为 0，而 A 节点状态小于 0 的时候一定不会被选中，因此 A 最多只能被连续选中 a - 1 轮。即每个节点也不会被连续选择，平滑性得证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Smooth Weighted Round-Robin (SWRR) 是 nginx 默认的加权负载均衡算法，它的重要特点是平滑，避免低权重的节点长时间处于空闲状态，因此被称为平滑加权轮询。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该算法来自 nginx 的一次 commit：&lt;a href=&quot;https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Upstream: smooth weighted round-robin balancing&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在阅读之前，你应该已经了解过 nginx 的几种负载均衡算法，并阅读了 SWRR 的实现。&lt;/p&gt;
&lt;p&gt;介绍此算法的文章有很多，但用数学角度给出证明过程的较少，尽管并不复杂。这里把自己的思路分享一下，为了便于理解，只考虑算法核心的 current_weight，忽略受异常波动影响的 effective_weight。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://claude-ray.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://claude-ray.com/tags/Nginx/"/>
    
      <category term="load balance" scheme="http://claude-ray.com/tags/load-balance/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Node.js 进程挂起的 BUG 追踪</title>
    <link href="http://claude-ray.com/2019/08/08/node-process-hang-up/"/>
    <id>http://claude-ray.com/2019/08/08/node-process-hang-up/</id>
    <published>2019-08-08T13:31:02.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先把干货放前面，辅助排查的 npm 模块有：<a href="https://github.com/myndzi/wtfnode" target="_blank" rel="noopener">wtfnode</a>，why-is-node-running，active-handles 等，使用方法差不多如下，可以查看各自的文档。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wtf = <span class="built_in">require</span>(<span class="string">'wtfnode'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// your codes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// track down</span></span><br><span class="line">wtf.dump();</span><br></pre></td></tr></table></figure><p>也可以更深入地排查，因为上述模块的核心都是 Node.js 文档未标注的两个接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process._getActiveHandles();</span><br><span class="line">process._getActiveRequests();</span><br></pre></td></tr></table></figure><p>好了，本篇到这里结束了，剩下的内容，劝你还是跳过吧：流水帐警告⚠️️ 翻车警告⚠️️</p><a id="more"></a><h1 id="问题经过"><a href="#问题经过" class="headerlink" title="问题经过"></a>问题经过</h1><p>背景是为 ts + egg 项目引入 apm 探针，由于 apm 必须在“启动文件”的第一行完成加载，即整个 egg 的生命周期开始之前，因此需要使用独立的脚本或指令进行启动。具体如何处理可以参考这篇<a href="http://claude-ray.com/2019/07/12/elastic-apm-node-egg">博客</a>。</p><p>问题就出在脱离了 egg 的声明周期，得额外管理不同运行环境下 apm-server（APM 数据采集服务器）的地址配置。可能第一时间就能想到 Node.js 的环境变量，思路没错，毕竟程序和 egg-bin 绑定，NODE_ENV 环境变量的命名符合规范，主要为 development、test、production。特定环境读取特定的即可。</p><p>但调试过程中，写错了 apm-server 路径，遇到了进程启动过程中卡住的现象。解决起来很容易，但好奇是什么原因造成的，因为正常引入 elastic-apm-node 并填写一个错误的 url 并不妨碍主流程的运行。</p><h1 id="战前准备"><a href="#战前准备" class="headerlink" title="战前准备"></a>战前准备</h1><p>省略翻代码的过程，简单的结论就是：进程卡死的问题由 egg-bin 内置的 ets（egg-ts-helper）指令诱发，其使用 <code>child_process.execSync</code> 方法启动子进程来预加载一部分代码用作检查，而子进程卡住不退出，才导致父进程无法继续向下执行。</p><blockquote><p>ets 执行 execSync 的位置：<a href="https://github.com/whxaxes/egg-ts-helper/blob/master/src/utils.ts#L107" target="_blank" rel="noopener">https://github.com/whxaxes/egg-ts-helper/blob/master/src/utils.ts#L107</a> 其中 cmd 的内容是执行 <code>./scripts/eggInfo</code> 文件。eggInfo 指令了 egg 的 loader 来获取插件信息，因此 apm 作为生命周期之前的模块被顺便加载了。</p></blockquote><p>经过检查和断点调试，已经找出进程无法正常退出的根源在 <code>elasitc-apm-http-client</code> 模块和 <code>apm-server</code> 的通讯之间。并且如果把 apm-server 的目标地址改成本机未使用的端口，如 <code>http://localhost:8201</code>，进程可迅速地正常退出。但如果填写一个错误地或不存在的地址，例如 <code>http://10.10.10.10:8200</code> ，以致访问超时，进程就会挂起。</p><h1 id="开始狩猎"><a href="#开始狩猎" class="headerlink" title="开始狩猎"></a>开始狩猎</h1><p>我们已经缩小了问题重现的范围，就可以仔细阅读代码了。</p><p>首先看向 http client 创建的步骤，唯一值得注意的点是一个轮询操作。apm 创建时默认开启了 elastic-apm-http-client 的 <code>centralConfig</code> 选项，此功能是允许在 Kibana 看板上直接修改 apm agent 的配置而无须重启 Node.js 进程，实现原理便是轮询 apm-server 以查询最新的配置信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Client.prototype._pollConfig = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> req = <span class="keyword">this</span>._transport.get(opts, res =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._scheduleNextConfigPoll()</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'request-error'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Client.prototype._scheduleNextConfigPoll = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._configTimer !== <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  seconds = seconds || <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._configTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._configTimer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>._pollConfig()</span><br><span class="line">  &#125;, seconds * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._configTimer.unref()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然轮询可怕，但上面已经为 Timeout 调用了 unref 方法。正常来说，只要没有其他 event loop 在运行，<code>Timer.unref()</code> 能够让 Node.js 进程在 Timeout 回调调用前退出，可以防止程序空转。</p><p>因此问题不在这段代码，为了验证推断，关闭此选项之后，果然依旧不能正常退出。</p><p>既然进程还在运转，就一定有其他的 event loop。在 elastic-apm-http-client 中继续寻找到了另一个 Timeout，该函数每次触发数据上报时都会被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Client.prototype._maybeCork = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._writableState.corked &amp;&amp; <span class="keyword">this</span>._conf.bufferWindowTime !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cork()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._corkTimer &amp;&amp; <span class="keyword">this</span>._corkTimer.refresh) &#123;</span><br><span class="line">      <span class="comment">// the refresh function was added in Node 10.2.0</span></span><br><span class="line">      <span class="keyword">this</span>._corkTimer.refresh()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._corkTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.uncork()</span><br><span class="line">      &#125;, <span class="keyword">this</span>._conf.bufferWindowTime)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._writableState.length &gt;= <span class="keyword">this</span>._conf.bufferWindowSize) &#123;</span><br><span class="line">    <span class="keyword">this</span>._maybeUncork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Timer.refresh()</code> 可以重置已执行的定时任务，这里很有可能是真正的问题点。</p><p>暂停代码阅读，先盲目猜测一波：在第一次请求超时之前，进程一定不会退出，但超时之后，将在 30 秒后才会重新发起新的请求，进程退出的机会就在这 30 秒。而 _maybeCork 这里虽然每次数据上报都会触发不经过 unref 处理的 setTimeout，奈何我查了 bufferWindowTime 默认才 20 毫秒。所以问题出在这里的可能性又很渺茫了，试下把这段注释掉，果然……<br>但凭着对 elastic-apm-node 项目的熟悉，性能指标的上报间隔恰好也是 30 秒，这里一定有个定时任务的，但之前直接在项目中搜索关键字未找到，就忽略了。</p><p>根据相关时间字段，又检索到了定时任务的创建地点 —— <code>measured-reporting</code> 模块，然而这里也做了 unref 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_createIntervalCallback(intervalInSeconds) &#123;</span><br><span class="line">  <span class="keyword">this</span>._log.debug(<span class="string">`_createIntervalCallback() called with intervalInSeconds: <span class="subst">$&#123;intervalInSeconds&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._reportMetricsWithInterval(intervalInSeconds);</span><br><span class="line">  &#125;, intervalInSeconds * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._unrefTimers) &#123;</span><br><span class="line">    timer.unref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._intervals.push(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="狩猎失败-超时"><a href="#狩猎失败-超时" class="headerlink" title="狩猎失败/超时"></a>狩猎失败/超时</h1><p>在 node_modules 中全局搜索了 setTimeout 以及 setInterval，排除了所有可疑迹象，剩下的连接就难排查了，迫于“生产力”，问题暂时追踪到这里。。。</p><h1 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h1><p>思考了对应的解决方案：</p><ol><li>将 ets 改成异步执行，但可能失去了前置检查的意义</li><li>分析并重写 elastic-apm-node 的连接机制</li><li>在 ets 执行时不启动 apm</li><li>做好连通性检测，确保 apm 的配置可靠再 apm.start()，但网络请求是异步的，会让 apm 之后整个项目的模块加载都在异步回调中处理</li></ol><p>1、2 的成本太高，而 4 没有做过可靠的测试，不保证不会对模块加载和优化产生副作用，所以最可行的方案是 3。</p><p>找准方向就开搞，通过 process.env 入手，关注几个比较有用的环境变量：</p><ol><li>process.env.NODE_ENV</li><li>process.env.ETS_REGISTER_PID，此变量存在时，证明有 ets 参与，不启动。但特别地，单独运行 <code>ets</code> 时没有此变量，也没有 NODE_ENV，应对方法是将 NODE_ENV 为 undefined 的环境也排除。</li><li>process.env.npm_lifecycle_event，是 npm 添加的当前执行的 npm script 名称标识。可以考虑为 start，restart 时才启动。</li></ol><p>补充方案：<br>通过 process.env 向 apm 传递自定义参数，便于控制配置项。</p><p>最后 apm 启动头部长这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 APM_ENABLE 作为开关条件</span></span><br><span class="line"><span class="keyword">const</span> enableAPM = process.env.APM_ENABLE || (process.env.NODE_ENV &amp;&amp; !process.env.ETS_REGISTER_PID);</span><br><span class="line"><span class="keyword">if</span> (enableAPM) &#123;</span><br><span class="line">  <span class="comment">// 除了 NODE_ENV，也可以使用自定义的 ENV</span></span><br><span class="line">  <span class="keyword">const</span> options = getOptionsByENV(process.env.NODE_ENV)</span><br><span class="line">  apm.start(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然没结论，但进程挂起的根本原因是没错的。找 BUG 最耗时的是方向歪了，试过用干净的 Node.js 代码模拟，没能复现问题。而 wtfnode 和其他跟踪模块，因为 callsite 覆盖问题，也没能提供清晰的调用栈，或许应该考虑从修复 callsite 这个方向入手？</p><p>To be continue? </p><p>但是意义不大了，从这堆充满 hack 的代码中并没有学到特别有价值的东西，而且时间成本太高。倒是警醒自己在 Timer 和 socket 的底层使用上，务必留意 unref 的处理。还是把时间留给更重要的事吧，衰！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先把干货放前面，辅助排查的 npm 模块有：&lt;a href=&quot;https://github.com/myndzi/wtfnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wtfnode&lt;/a&gt;，why-is-node-running，active-handles 等，使用方法差不多如下，可以查看各自的文档。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; wtf = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;wtfnode&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// your codes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// track down&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wtf.dump();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;也可以更深入地排查，因为上述模块的核心都是 Node.js 文档未标注的两个接口：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;process._getActiveHandles();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;process._getActiveRequests();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;好了，本篇到这里结束了，剩下的内容，劝你还是跳过吧：流水帐警告⚠️️ 翻车警告⚠️️&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://claude-ray.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>警惕 Travis CI 的 npm 缓存</title>
    <link href="http://claude-ray.com/2019/08/01/travis-npm-cache/"/>
    <id>http://claude-ray.com/2019/08/01/travis-npm-cache/</id>
    <published>2019-08-01T13:56:25.000Z</published>
    <updated>2022-06-29T03:16:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>从 2019 年 7 月份开始，Travis CI 默认开启 npm 缓存。这意味着 node_module 和 package-lock.json 会在初次构建时缓存，倘若后续更新 npm 依赖而不刷新该缓存，可能带来构建失败的问题。</p><a id="more"></a><p>下面是发现问题的源头。</p><p>在为一个项目添加了新的依赖 rimraf 之后，Travis CI 意外地报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh: 1: rimraf: not found</span><br></pre></td></tr></table></figure><p>此时 <code>.travis.yml</code> 配置为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">i</span> <span class="string">npminstall</span> <span class="string">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npminstall</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">ci</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npminstall</span> <span class="string">codecov</span> <span class="string">&amp;&amp;</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p>很明显新增的 npm 依赖没有安装上，但本地测试没有问题，于是替换 npminstall 为原生的 npm install，降低问题排查范围。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'8'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'10'</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">ci</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">codecov</span> <span class="string">&amp;&amp;</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p>然而移除 npminstall 之后，报错变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection RangeError: Maximum call stack size exceeded</span><br><span class="line">    at RegExp.test (&lt;anonymous&gt;)</span><br><span class="line">    at &#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;node_modules&#x2F;aproba&#x2F;index.js:38:16</span><br><span class="line">    at Array.forEach (&lt;anonymous&gt;)</span><br><span class="line">    at module.exports (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;node_modules&#x2F;aproba&#x2F;index.js:33:11)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:37:3)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br><span class="line">    at flatNameFromTree (&#x2F;home&#x2F;travis&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.16.0&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;lib&#x2F;install&#x2F;flatten-tree.js:39:14)</span><br></pre></td></tr></table></figure><p>之后，去掉 rimraf 依赖于事无济，重跑其他 node 项目的 ci 却一切正常，因此最终确定是 travis 运行环境带来的问题。</p><p>果然，寻找刷新方法的过程中发现了右侧 <code>More options</code> 中的 <code>Caches</code> 选项，点击里面的删除键后，CI 重新运行成功。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.travis-ci.com/user/caching/#npm-cache" target="_blank" rel="noopener">https://docs.travis-ci.com/user/caching/#npm-cache</a></p><blockquote><p>Please note that as of July 2019, npm is cached by default on Travis CI</p></blockquote><p>To disable npm caching, use:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">npm:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 2019 年 7 月份开始，Travis CI 默认开启 npm 缓存。这意味着 node_module 和 package-lock.json 会在初次构建时缓存，倘若后续更新 npm 依赖而不刷新该缓存，可能带来构建失败的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CI" scheme="http://claude-ray.com/categories/CI/"/>
    
    
      <category term="Travis" scheme="http://claude-ray.com/tags/Travis/"/>
    
      <category term="CI" scheme="http://claude-ray.com/tags/CI/"/>
    
  </entry>
  
</feed>
